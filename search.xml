<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python网络数据采集之图像识别与文字处理|第10天]]></title>
    <url>%2Fposts%2F55181%2F</url>
    <content type="text"><![CDATA[图像识别与文字处理； 使用Pillow库和Tesseract。 图像识别与文字处理将图像翻译成文字一般被称为光学文字识别(Optical Character Recognition，OCR)。可以实现 OCR 的底层库并不多，目前很多库都是使用共同的几个底层 OCR 库，或者是在上面进行定制。 OCR库概述Python常用的OCR库有两个：Pillow 和 Tesseract。每个库都可以从它们的网站上下载并安装(http://pillow.readthedocs.org/installation.html 和https://pypi.python.org/pypi/pytesseract)，或者用第三方管理器(像 pip)通过“pillow”和 “pytesseract”进行安装。 PillowPillow 是从 Python 2.x版本的 Python图像库(Python Imaging Library，PIL)分出来的，支持Python 3.x版本。和PIL一样，Pillow也可以轻松地导入代码，并通过大量的过滤、修饰甚至像素级的变换操作处理图片: 123456from PIL import Image,ImageFilterkitten = Image.open("demo.jpg")#打开图片blurryKitten = kitten.filter(Imagefilter.GaussianBlur)blurryKitten.save("demo_two.jpg")#另存为blurryKitten.show() TesseractTesseract 是目前公认最优秀、最精确的开源 OCR 系统。Tesseract 也具有很高的灵活性。它可以通过训练识别出任何字体，也可以识别出任何Unicode字符。 Tesseract 是一个 Python的命令行工具，不是通过 import语句导入的库。安装之后，要用 tesseract 命令在Python的外面运行。 安装 Tesseract Windows:点击下载安装 Linux:sudo apt-get tessertact-ocr Mac: brew install tesseract;也可以下载源码安装 NumPyNumPy 是一个非常强大的库，具有大量线性代数 以及大规模科学计算的方法。因为NumPy可以用数学方法把图片表示成巨大的像素数组，所以它可以流畅地配合 Tesseract 完成任务。 NumPy 可以通过第三方包管理器(比如 pip)来安装:pip install numpy 处理格式规范的文字例如通过运行Tesseract，读取文件并把结果写到一个文本文件中: 1tesseract text.tif textoutput | cat test.txt Tesseract 最大的缺点是对渐变背景色的处理。利用Pillow 库，我们可以创建一个阈值过滤器来去掉渐变的背景色，只把文字留下来，从而让图片更加清晰，便于 Tesseract 读取: 123456789101112131415from PIL import Imageimport subprocessdef cleanFile(filePath, newFilePath): image = Image.open(filePath) # 对图片进行阈值过滤，然后保存 image = image.point(lambda x: 0 if x&lt;143 else 255) image.save(newFilePath) # 调用系统的tesseract命令对图片进行OCR识别 subprocess.call(["tesseract", newFilePath, "output"]) # 打开文件读取结果 outputFile = open("output.txt", 'r') print(outputFile.read()) outputFile.close()cleanFile("text_2.jpg", "text_2_clean.png") 在提交给 Tesseract 处理之前，那些带标题的、带有大片空白的图片，或者有其他问题的图 片，都应该做预处理。 今天的内容没有特别难，我写的比较简单，爬取网络的图片和验证码识别还没写，先从简单的消化。 欢迎你免费加入我的星球，一起分享，共同成长。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据采集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络数据采集之采集JavaScript|第09天]]></title>
    <url>%2Fposts%2F12496%2F</url>
    <content type="text"><![CDATA[了解JavaScript； 使用selenium库和phantomjs。 采集JavaScript客户端脚本语言是运行在浏览器而非服务器上的语言。客户端语言成功的前提是浏览器拥有正确地解释和执行这类语言的能力。 到目前为止，JavaScript 是网络上最常用也是支持者最多的客户端脚本语言。它可以收集 用户的跟踪数据，不需要重载页面直接提交表单，在页面嵌入多媒体文件，甚至运行网页游戏。那些看起来非常简单的页面背后通常使用了许多 JavaScript 文件。 例如： 123&lt;script type="text/javascript" &gt; alert("这是一个JavaScript的文件！")&lt;script&gt; JavaScript简介几个关键字了解一下：弱类型语言，其他语言有的基本都有。JavaScript里所有的变量都用 var关键词字进行定义，可以把函数作为变量使用。 1234567891011121314&lt;script&gt; var fibonacci = function() &#123; var a = 1; var b = 1; return function() &#123; var temp = b; b = a + b; a = temp; return b; &#125; &#125;var fibInstance = fibonacci();console.log(fibInstance()+" is in the Fibonacci sequence");console.log(fibInstance()+" is in the Fibonacci sequence");console.log(fibInstance()+" is in the Fibonacci sequence"); &lt;/script&gt; 上面的例子看一下就好，熟悉一下就可以，就是这么简单。 常用的JavaScript库有很多。例如jQuery,Google Analytics,React等等，了解一下。 Ajax和动态HTML与网站服务器通信的唯一方式，就是发出HTTP请求获取新页面,如果提交表单之后，或从服务器获取信息之后，网站的页面不需要重新刷新，那么你访问的网站就在用Ajax 技术。 Ajax全称是Asynchronous JavaScript and XML(异步 JavaScript和 XML)，网站不需要使用单独的页面请求就可以和网络服务器进行交互 (收发信息)。 在Python中用Selenium执行JavaScriptSelenium是一个强大的网络数据采集工具，其最初是为网站自动化测试而开发的。近几年，它还被广泛用于获取精确的网站快照，因为它们可以直接运行在浏览器上。Selenium可以让浏览器自动加载页面，获取需要的数据，甚至页面截屏，或者判断网站上某些动作是否发生。Selenium 自己不带浏览器，它需要与第三方浏览器结合在一起使用。 我们可以用一个叫PhantomJS的工具代替真实的浏览器。PhantomJS 是一个“无头”(headless)浏览器。它会把网站加载到内存并执行页面上的 JavaScript，但是它不会向用户展示网页的图形界面。把 Selenium和 PhantomJS 结合在一 起，就可以运行一个非常强大的网络爬虫了，可以处理 cookie、JavaScrip、header，以及任何你需要做的事情。 安装Selenium可以去其官网下载安装，也可以直接pip来安装这个库，非常简单。但是PhantomJS不是库，不能直接用pip安装，可以直接去官网下载页面下载安装，同时如果你是Mac的用户可以通过homebrew安装： 1brew install phantomjs Selenium 库是一个在 WebDriver 上调用的 API。WebDriver 有点儿像可以加载网站的浏览器，但是它也可以像 BeautifulSoup 对象一样用来查找页面元素，与页面上的元素进行交互 (发送文本、点击等)，以及执行其他动作来运行网络爬虫。 12345678from selenium import webdriverimport timedriver = webdriver.PhantomJS(executable_path='/usr/local/Cellar/phantomjs/2.1.1/bin/phantomjs') #创建了一个新的Selenium WebDriver，需要指定自己的phantomjs路径driver.get("http://pythonscraping.com/pages/javascript/ajaxDemo.html") #用WebDriver加载页面time.sleep(3) #暂停3秒执行print(driver.find_element_by_id('content').text) #查看页面内容driver.close() 处理重定向客户端重定向是在服务器将页面内容发送到浏览器之前，由浏览器执行 JavaScript 完成的 页面跳转，而不是服务器完成的跳转。当使用浏览器访问页面的时候，有时很难区分这两种重定向。由于客户端重定向执行很快，加载页面时你甚至感觉不到任何延迟，所以会让你觉得这个重定向就是一个服务器端重定向。 服务端重定向可以通过urllib库来解决，但是客户端的重定向不能这样处理。Selenium 可以执行这种 JavaScript 重定向，和它处理其他 JavaScript 的方式一样;但是这类重定向的主要问题是什么时候停止页面监控，也就是说，怎么识别一个页面已经完成重定向。 我们可以用一种智能的方法来检测客户端重定向是否完成，首先从页面开始加载 时就“监视”DOM 中的一个元素，然后重复调用这个元素直到 Selenium 抛出一个StaleElementReferenceException 异常;也就是说，元素不在页面的 DOM 里了，说明这时网站已经跳转: 1234567891011121314151617181920212223from selenium import webdriverimport timefrom selenium.webdriver.remote.webelement import WebElementfrom selenium.common.exceptions import StaleElementReferenceExceptiondef waitForLoad(driver): elem = driver.find_element_by_tag_name("html") count = 0 while True: count += 1 if count &gt; 20: print("Timing out after 10 seconds and returning") return time.sleep(.5) try: elem == driver.find_element_by_tag_name("html") except StaleElementReferenceException: returndriver = webdriver.PhantomJS(executable_path='drivers/phantomjs/phantomjs-2.1.1-macosx/bin/phantomjs')driver.get("http://pythonscraping.com/pages/javascript/redirectDemo1.html")waitForLoad(driver)print(driver.page_source) 正式邀请你免费加入我的星球，一起分享，共同成长。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
        <tag>数据采集</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络数据采集之登录窗口采集处理|第08天]]></title>
    <url>%2Fposts%2F64604%2F</url>
    <content type="text"><![CDATA[利用Requests库处理Cookie、session等方式的登录。 登录窗口采集处理如果我们采集的网站需要我们登录后才能获取我们想要的数据，这就需要进一步处理登录这个问题。 登录的原理很简单，即前台向服务器传输数据进行验证。传输的方式有很多种，例如GET、POST；页面表单基本上可以看成是一种用户提交 POST请求的方式，且这种请求方式是服务器能够理解和使用的。 Python Requests库除了Python的标准库urllib库，还有第三方库可以选择，例如：Requests。主要擅长处理那些复杂的 HTTP 请求、cookie、header(响应头和请求头)等内容的 Python第三方库。 项目地址：https://github.com/kennethreitz/requests/ 安装的方式也很简单。例如pip安装，或者下载源码安装。 源码地址：https://github.com/kennethreitz/requests/tarball/master 提交表单提交表单一般是HTML的方式可以实现，且大多也采用这样的方式进行提交。例如： 12345&lt;form method="post" action="processing.php"&gt;Nickename: &lt;input type="text" name="nickename"&gt;&lt;br&gt; username: &lt;input type="text" name="username"&gt;&lt;br&gt; &lt;input type="submit" value="Submit"&gt;&lt;/form&gt; 我们Python的用Requests库来提交十分简单。 1234import requestsparams = &#123;'name': 'Ryan', 'username': 'Mitchell'&#125;r = requests.post("http://pythonscraping.com/files/processing.php", data=params)print(r.text) 单选按钮、复选框等输入无论表单的字段看起来多么复杂，仍然只有两件事是需要关注的:字段名称和值。字段名称可以通过查看源代码寻找name 属性轻易获得。而字段的值有时会比较复杂，有可能是在表单提交之前通过 JavaScript 生成的。 我们可以通过抓包或者浏览器的网络请求信息来判断，例如： 1https:chensenlin.cn?c=hello&amp;m=senlin Python需要理解为： 1&#123;'c':'hello','m':'senlin'&#125; 具体查看方法可以参考下图所示： 提交文件或者图像HTML提交文件的时候，需要添加一个参数enctype=&quot;multipart/form-data&quot;,声明这是文件上传的类型。同时input的type为file。 1234&lt;from action="uploadFile.php" metoh="post" enctype="multipart/form-data"&gt;uploadFile:&lt;input type="file" name="filename"&gt;提交：&lt;input type="submit" value="上传"&gt;&lt;/from&gt; 同理，Python Requests 库对这种表单的处理方式如下： 12345import requests files = &#123;'uploadFile': open('../files/Python-logo.png', 'rb')&#125; r = requests.post("https:chensenlin.cn?c=filename&amp;m=upload",files=files)print(r.text) 处理登录和Cookie网站大多都用 cookie 跟踪用户是否已登录的状态信息。一旦网站验证了你的登录权证，它就会将它们保存在你的浏览器的 cookie 中，里面通常包含一个服务器生成的令牌、登录有效时限和状态跟踪信息。网站会把这个cookie当作信息验证的证据，在你浏览网站的每个页面时出示给服务器。 根据我们上面的逻辑用Requests库跟踪cookie的代码示例也比较简单： 1234567891011import requestsparams = &#123;'username': 'demochen', 'password': 'password'&#125;r = requests.post("http://pythonscraping.com/pages/cookies/welcome.php", params)print("Cookie is set to:")print(r.cookies.get_dict())print("-----------")print("Going to profile page...")r = requests.get("http://pythonscraping.com/pages/cookies/profile.php",cookies=r.cookies)print(r.text) 不过也有session的方式进行登录,但是Requests库的session函数处理也很方便。具体和cookie类似，不过多阐述,或者查看文档了解也可以。 12345678910import requestssession = requests.Session()params = &#123;'username': 'username', 'password': 'password'&#125;s = session.post("http://pythonscraping.com/pages/cookies/welcome.php", params)print("Cookie is set to:")print(s.cookies.get_dict())print("-----------")print("Going to profile page...")s = session.get("http://pythonscraping.com/pages/cookies/profile.php") print(s.text) 值得注意的是，登录还有一种是用HTTP基本接入认证的方式。Requests库有一个 auth模块专门用来处理 HTTP 认证: 1234567import requestsfrom requests.auth import AuthBasefrom requests.auth import HTTPBasicAuth auth = HTTPBasicAuth('ryan', 'password') r = requests.post(url="http://pythonscraping.com/pages/auth/login.php", auth=auth)print(r.text) 正式邀请你免费加入我的星球，一起分享，共同成长。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
        <tag>数据采集</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络数据采集之处理自然语言|第07天]]></title>
    <url>%2Fposts%2F54692%2F</url>
    <content type="text"><![CDATA[处理自然语言包括自然语言工具包和数据概括。 处理自然语言概括数据在之前我们了解了如何把文本内容分解成 n-gram 模型，或者说是n个单词长度的词组。从最基本的功能上说，这个集合可以用来确定这段文字中最常用的单词和短语。另外，还可以提取原文中那些最常用的短语周围的句子，对原文进行看似合理的概括。 例如我们根据威廉 ·亨利 ·哈里森的就职演全文进行分析。文章地址 123456789101112131415161718192021222324252627282930313233343536373839404142from urllib.request import urlopenfrom bs4 import BeautifulSoupimport reimport stringfrom collections import Counterdef cleanSentence(sentence): sentence = sentence.split(' ') sentence = [word.strip(string.punctuation+string.whitespace) for word in sentence] sentence = [word for word in sentence if len(word) &gt; 1 or (word.lower() == 'a' or word.lower() == 'i')] return sentencedef cleanInput(content): content = content.upper() content = re.sub('\n', ' ', content) content = bytes(content, 'UTF-8') content = content.decode('ascii', 'ignore') sentences = content.split('. ') return [cleanSentence(sentence) for sentence in sentences]def getNgramsFromSentence(content, n): output = [] for i in range(len(content)-n+1): output.append(content[i:i+n]) return outputdef getNgrams(content, n): content = cleanInput(content) ngrams = Counter() ngrams_list = [] for sentence in content: newNgrams = [' '.join(ngram) for ngram in getNgramsFromSentence(sentence, n)] ngrams_list.extend(newNgrams) ngrams.update(newNgrams) return(ngrams)content = str( urlopen('http://pythonscraping.com/files/inaugurationSpeech.txt').read(), 'utf-8')ngrams = getNgrams(content, 3)print(ngrams) 自然语言工具包自然语言工具包(Natural Language Toolkit，NLTK)就是这样一个 Python库，用于识别和标记英语文本中各个词的词性(parts of speech)。 安装与配置NLTK网站(http://www.nltk.org/install.html)。安装软件比较简单，例如pip安装。 123456789101112➜ psysh git:(master) pip install nltkCollecting nltk Using cached nltk-3.2.5.tar.gzRequirement already satisfied: six in /usr/local/lib/python3.6/site-packages (from nltk)Building wheels for collected packages: nltk Running setup.py bdist_wheel for nltk ... done Stored in directory: /Users/demo/Library/Caches/pip/wheels/18/9c/1f/276bc3f421614062468cb1c9d695e6086d0c73d67ea363c501Successfully built nltkInstalling collected packages: nltkSuccessfully installed nltk-3.2.5You are using pip version 9.0.1, however version 9.0.3 is available.You should consider upgrading via the 'pip install --upgrade pip' command. 检测一下就OK 123456➜ psysh git:(master) pythonPython 3.6.4 (default, Mar 1 2018, 18:36:50)[GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import nltk&gt;&gt;&gt; 输入nltk.download()就可以看到NLTK下载器。 默认下载全部的包，新手减少排除的相关的麻烦。 用NLTK做统计分析用NLTK做统计分析一般是从Text对象开始的。Text对象可以通过下面的方法用简单的 Python字符串来创建: 12345from nltk import word_tokenize from nltk import Texttokens = word_tokenize("哈哈哈哈哈")text = Text(tokens) word_tokenize函数的参数可以是任何Python字符串。如果你手边没有任何长字符串，但是还想尝试一些功能，在NLTK库里已经内置了几本书，可以用import函数导入: 1from nltk.book import * 统计文本中不重复的单词，然后与总单词数据进行比较:&gt;&gt;&gt; len(text6)/len(words)。 正式邀请你免费加入我的星球，一起分享，共同成长。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
        <tag>数据采集</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络数据采集之数据清洗|第06天]]></title>
    <url>%2Fposts%2F48792%2F</url>
    <content type="text"><![CDATA[主要内容：数据清洗。 昨天有朋友在微信问我怎么没有更新，昨天回家整理了一些相关的东西，没来得及写文章。今天一个朋友听说我在简书分享，也和我一同加入了简书，很喜欢这样的感觉。之前军哥跟我说过，慢慢尝试去写，然后会有一部分人会被你影响，我发现是真的，真的能够影响到一部分人。闲话少说，开始今天的内容。 数据清洗 从本章开始，内容稍微复杂一点，但也不是那么难。 记得之前我在爬去boss网站的招聘信息的时候，抓取的数据并非我们所理想的样式，后面经过处理后，成为一个自己想要的样子，这个过程可以理解为数据清洗。这里的处理是在代码处理的，不是手工完成。 编写代码清洗数据在此之前需要了解一下n-gram模型，它表示文字或语言中的n 个连续的单词组成的序列。在进行自然语言分析时，使用 n-gram或者寻找常用词组，可以很容易地把一句话分解成若干个文字片段。更多详情可以去维基查看一下，或者自行搜索。 下面通过代码将返回维基百科词条“Python programming language”的2-gram列表: 12345678910111213141516from urllib.request import urlopenfrom bs4 import BeautifulSoupdef getNgrams(content, n): content = content.split(' ') output = [] for i in range(len(content)-n+1): output.append(content[i:i+n]) return outputhtml = urlopen('http://en.wikipedia.org/wiki/Python_(programming_language)')bs = BeautifulSoup(html, 'html.parser')content = bs.find('div', &#123;'id':'mw-content-text'&#125;).get_text()ngrams = getNgrams(content, 2)print(ngrams)print('2-grams count is: '+str(len(ngrams))) ngrams 函数把一个待处理的字符串分成单词序列(假设所有单词按照空格分开)，然后增加到 n-gram 模型(本例中是 2-gram)里形成以每个单词开始的二元数组。 我们得到的数据部分如下： 1[['\nPython\n\n\n\n\nParadigm\nObject-oriented,', 'imperative,'], ['imperative,', 'functional,'], ['functional,', 'procedural,'], ['procedural,', 'reflective\n\n\nDesigned\xa0by\nGuido'], 显然，是需要处理的。 首选处理通过正则移除\n，再把 Unicode 字符过滤掉。先把内容中的换行符(或者多个换行符)替换成空格，然后把连续的多个空格替换成一个空格，确保所有单词之间只有一个空格。最后，把内容转换成 UTF-8 格式以消除转义字符。函数初步如下： 1234567891011def ngrams(input, n): content = re.sub('\n+', " ", content) content = re.sub(' +', " ", content) content = bytes(content, "UTF-8") content = content.decode("ascii", "ignore") print(content) input = input.split(' ') output = [] for i in range(len(input)-n+1): output.append(input[i:i+n]) return output Python获取所有的标点符号： 1234567➜ url pythonPython 3.6.4 (default, Mar 1 2018, 18:36:50)[GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import string&gt;&gt;&gt; string.punctuation'!"#$%&amp;\'()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~' 我们还要去除一些维基引用的标记、标点符号等；进一步进行清洗的函数： 1234567891011121314151617181920212223from urllib.request import urlopen from bs4 import BeautifulSoup import reimport stringdef cleanInput(input): input = re.sub('\n+', " ", input) input = re.sub('\[[0-9]*\]', "", input) input = re.sub(' +', " ", input) input = bytes(input, "UTF-8") input = input.decode("ascii", "ignore") cleanInput = [] input = input.split(' ') for item in input: item = item.strip(string.punctuation) if len(item) &gt; 1 or (item.lower() == 'a' or item.lower() == 'i'): cleanInput.append(item) return cleanInput def ngrams(input, n): input = cleanInput(input) output = [] for i in range(len(input)-n+1): output.append(input[i:i+n]) return output 这样处理后，我们的结果就稍微好点。 123['Linux', 'Foundation'], ['Foundation', 'Mozilla'], ['Mozilla', 'Foundation'], [ 'Foundation', 'Open'], ['Open', 'Knowledge'], ['Knowledge', 'Foundation'], ['Fou ndation', 'Open'], ['Open', 'Source'] 数据存储后再清洗对于编写代码清洗数据，你能做或想做的事情只有这些。除此之外，你可能还需要处理一些别人创建的数据库，或者要对一个之前没接触过的数据库进行清洗。 主要额方法有编写脚本或者第三方工具。例如OpenRefine。本小节主要是介绍一下该软件的安装和使用。也可以理解为一个图形化的应用，对于工具类的东西我一直有一个观点：点点点，就会了；何况还是图形化的。所以我不做介绍，看一下官网的三个视频就会了。 官网地址：http://openrefine.org/ 正式邀请你免费加入我的星球，一起分享，共同成长。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
        <tag>数据采集</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络数据采集之读取文档|第05天]]></title>
    <url>%2Fposts%2F34041%2F</url>
    <content type="text"><![CDATA[主要内容： 文档编码和类型的介绍； 读取CSV、PDF等格式的文件。 读取文档文档编码文档编码的方式通常可以根据文件的扩展名进行判断，虽然文件扩展名并不是由编码确定的，而是由开发者确定的。从最底层的角度看，所有文档都是由 0和 1 编码而成的。例如我我们将一个后缀为png的图片后缀改为.py。用编辑器打打开就完全不对了。 只要安装了合适的库， Python 就可以帮你处理任意类型的文档。纯文本文件、视频文件和图像文件的唯一区别，就是它们的 0和1 面向用户的转换方式不同。 纯文本对于纯文本的文件获取的方式很简单，用 urlopen 获取了网页之后，我们会把它转变成 BeautifulSoup对象。 123456from urllib.request import urlopen textPage = urlopen("http://www.pythonscraping.com/pages/warandpeace/chapter1.txt") print(textPage.read()) CSV 文件Python有一个标准库对CSV文件的处理特别的友好，可以处理各类的CSV文件。文档地址 读取CSV文件Python 的csv 库主要是面向本地文件，就是说你的 CSV 文件得存储在你的电脑上。而进行网络数据采集的时候，很多文件都是在线的。有几个参考解决办法： 手动把CSV文件下载到本机，然后用Python定位文件位置; 写Python程序下载文件，读取之后再把源文件删除; 从网上直接把文件读成一个字符串，然后转换成一个StringIO对象，使它具有文件的属性。 例如获取网上的CSV文件，然后输出命令行。 1234567891011from urllib.request import urlopenfrom io import StringIOimport csvdata = urlopen("http://pythonscraping.com/files/MontyPythonAlbums.csv").read().decode('ASCII','ignore')dataFile = StringIO(data)csvReader = csv.reader(dataFile)for row in csvReader: print(row) 输出的结果： 12345678910111213141516['Name', 'Year']["Monty Python's Flying Circus", '1970']['Another Monty Python Record', '1971']["Monty Python's Previous Record", '1972']['The Monty Python Matching Tie and Handkerchief', '1973']['Monty Python Live at Drury Lane', '1974']['An Album of the Soundtrack of the Trailer of the Film of Monty Python and the Holy Grail', '1975']['Monty Python Live at City Center', '1977']['The Monty Python Instant Record Collection', '1977']["Monty Python's Life of Brian", '1979']["Monty Python's Cotractual Obligation Album", '1980']["Monty Python's The Meaning of Life", '1983']['The Final Rip Off', '1987']['Monty Python Sings', '1989']['The Ultimate Monty Python Rip Off', '1994']['Monty Python Sings Again', '2014'] PDF 文件PDFMiner3K是一个非常好用的库(是PDFMiner的Python 3.x移植版)。它非常灵活，可以通过命令行使用，也可以整合到代码中。它还可以处理不同的语言编码，而且对网络文件的处理也非常方便。 下载解压后用python setup.py install完成安装。 模块的源文件下载地址： https://pypi.python.org/pypi/pdfminer3k 例如可以把任意 PDF 读成字符串，然后用 StringIO转换成文件对象。 123456789101112131415161718192021from urllib.request import urlopenfrom pdfminer.pdfinterp import PDFResourceManager, process_pdffrom pdfminer.converter import TextConverterfrom pdfminer.layout import LAParamsfrom io import StringIOfrom io import opendef readPDF(pdfFile): rsrcmgr = PDFResourceManager() retstr = StringIO() laparams = LAParams() device = TextConverter(rsrcmgr, retstr, laparams=laparams) process_pdf(rsrcmgr, device, pdfFile) device.close() content = retstr.getvalue() retstr.close() return content pdfFile = urlopen("http://pythonscraping.com/pages/warandpeace/chapter1.pdf")outputString = readPDF(pdfFile)print(outputString)pdfFile.close() readPDF 函数最大的好处是，如果PDF文件在电脑里，就可以直接把 urlopen返回的对象 pdfFile 替换成普通的 open() 文件对象: 1pdfFile = open("./chapter1.pdf", 'rb') 正式邀请你免费加入我的星球，一起分享，共同成长。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
        <tag>数据采集</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络数据采集之存储数据|第04天]]></title>
    <url>%2Fposts%2F60544%2F</url>
    <content type="text"><![CDATA[主要内容： 下载文件，存储数据； MySQL的基本使用，发送邮件。 存储数据网络数据的采集，最本质的东西还是数据，我们爬取的数据是需要存储的。 媒体文件存储媒体文件有两种主要的方式:只获取文件 URL 链接，或者直接把源文件下载下来。 可以通过媒体文件所在的URL 链接直接引用它。这样做的优点如下: 爬虫运行得更快，耗费的流量更少，因为只要链接，不需要下载文件; 可以节省很多存储空间，因为只需要存储URL链接就可以; 存储URL的代码更容易写，也不需要实现文件下载代码; 不下载文件能够降低目标主机服务器的负载。 于此同时还会有一些缺点： 网站防盗链的问题，会带来很多的麻烦； 自主性较差，因为文件在别人的服务器上，可支配性差； 链接可能是会变化的，失效的链接数增加。 …. 下载文件的方法也很简单，在Python 3.x 版本中,urllib.request.urlretrieve可以根据文件的 URL 下载文件; 例如我们从http://pythonscraping.com 下载 logo图片，然后在程序运行的文件夹里保存为 logo.jpg 文件。 12345678from urllib.request import urlretrievefrom urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen('http://www.pythonscraping.com')bs = BeautifulSoup(html, 'html.parser')imageLocation = bs.find('a', &#123;'id': 'logo'&#125;).find('img')['src']urlretrieve (imageLocation, 'logo.jpg') 下载文件需要注意exe的文件，木马文件等。不要在硬盘存储敏感信息，不要用管理员权限运行他。 把数据存储到CSVCSV(Comma-Separated Values，逗号分隔值)是存储表格数据的常用文件格式。关于CSV格式的文件不做过多的介绍，自行去了解一下。 Python的csv库可以创建或者修改CSV文件。 1234567891011import csv csvFile = open("./demo.csv","我+")try: writer = csv.writer(csvFile) writer.writerow(('number', 'number plus 2', 'number times 2')) for i in rang(10): writer.writerow((i,i+2,I*2))finally: csvFile.close() 如果文件不存在就会创建demo.csv。 MySQLMySQL是目前最受欢迎的开源关系型数据库管理系统。因为它受众广泛，免费，开箱即用，所以它也是网络数据采集项目中常用的数据库。 我采用的是Mac的平台，可以直接下载安装安装也可以通过包管理器(例如homebrew)安装。 官网下载地址：http://dev.mysql.com/downloads/mysql/ 其他的平台可以去官网查看安装详情，作为一个改变世界的程序猿，安装软件应该不是问题。 基本命令创建数据库: 1CREATE DATABASE demo; 使用数据库： 1USE demo; 创建表： 1234567CREATE TABLE user( id BIGINT(7) NOT NULL AUTO_INCREMENT, name VARCHAR(10), sex tinyint(1), creatime TIMESTAMP DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY(id)); 和数据库不同，MySQL 数据表必须至少有一列，否则不能创建。为了在 MySQL 里定义字段(数据列)，你必须在 CREATE TABLE &lt;tablename&gt; 语句后面，把字段的定义放进一个带括号的、内部由逗号分隔的列表。 插入数据： 1INSERT INTO user (name, sex) VALUES ("name", "1"); 查询数据： 1SELECT * FROM user 模糊查询： 12SELECT id FROM user LIKE "%chensenlin.cn%" 删除数据： 1DELELT FROM user WHERE id = 1 更新数据： 1UPDATE user SET name = 'chensenlin' WHERE id = 66 特别强调：更新或者删除一定要加条件！否则就说灾难，哈哈哈 与Python整合Python没有内置的MySQL 支持工具。不过，有很多开源的库可以用来与 MySQL做交互，Python 2.x和Python 3.x版本都支持。最有名的一个库就是PyMySQL(https://github.com/PyMySQL/PyMySQL)。 安装： 1pip install PyMySQL 基本使用： 12345678import pymysqlconn = pymysql.connect(host='127.0.0.1', unix_socket='/tmp/mysql.sock',user='root', passwd=root, db='mysql')cur.execute("USE demo")cur.execute("SELECT * FROM user WHERE id = 1") print(cur.fetchone())cur.close()conn.close() EmailPython发送一封邮件： 12345678910import smtplibfrom email.mime.text import MIMETextmsg = MIMEText("邮件正文内容")msg['Subject'] = "这是一个测试有奖主题"msg['From'] = "fore@gmail.com"msg['To'] = "hellosenlin@sina.cn"s = smtplib.SMTP('localhost')s.send_message(msg)s.quit() 与网页通过HTTP协议传输一样，邮件是通过SMTP(Simple Mail Transfer Protocol，简单邮件传输协议)传输的。而且,和网络服务器的客户端(浏览器)处理那些通过 HTTP 协议传输的网页一样。 可以将其封装成函数作为发送邮件定时使用等。 正式邀请你免费加入我的星球，一起分享，共同成长。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
        <tag>数据采集</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络数据采集之使用API|第03天]]></title>
    <url>%2Fposts%2F37773%2F</url>
    <content type="text"><![CDATA[本节比较简单，有开发经验可以跳过。 使用APIAPI概述百度百科关于API的解释：API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 说明这就是接口，不受其语言的限制都可以调用。 API通用规则API用一套非常标准的规则生成数据，而且生成的数据也是按照非常标准的方式组织的。 方法利用HTTP请求网络服务器信息的方法有很多种，这里举例常用的四种：GET：从服务器获取数据的方法；POST：向服务器发送数据。例如提交表单到服务器处理的逻辑；PUT：主要用来更新一个对象或信息，一般很少用到；DELETE：从服务器删除一个对象。 验证API并不是随时或者谁都可以调用的。为了保证服务器上的安全或者减少资源等目的，我们会对请求的方法或者次数有限制。通常情况会对接口进行验证，一般的验证方法是令牌（token），这个令牌一般是用户登录或者注册的时候从服务器生成然后给用户。令牌可以是可变的，也可以是不可变的。令牌除了在 URL链接中传递，还会通过请求头里的 cookie 把用户信息传递给服务器。简单示例： 123token = "&lt;your api key&gt;"webRequest = urllib.request.Request("http://myapi.com", headers=&#123;"token":token&#125;)html = urlopen(webRequest) 服务器响应服务器响应的数据格式一般是JSON或者XML。目前JSON比较多，原因有很多，其中一点就是JSON 文件比完整的 XML 格式小；加上网络技术的改变，后端的语言越来越多，基本上都可以实现接口。 API调用的语法也有不同，但也有约定俗成的准则。例如，当使用 GET请求获取数据时，用URL 路径描述你要获取的数据范围，查询参数可以作为过滤器或附加请求使用;也有许多 API 会通过文件路径(path)的形式指定 API 版本、数据格式和其他属性；还有一些 API会通过请求参数(request parameter)的形式指定数据格式和 API 版本: 市面上比较多的公司或者网站都有自己的公开的接口，例如推特，Google等。 解析JSON数据例如我们采用GET的方式请求http://freegeoip.net/json/50.78.253.58,查看返回的数据。返回为： 1&#123;"ip":"50.78.253.58","country_code":"US","country_name":"United States","region_code":"MA","region_name":"Massachusetts","city":"Boston","zip_code":"02116","time_zone":"America/New_York","latitude":42.3496,"longitude":-71.0746,"metro_code":506&#125; 现在我们采用Python来解析。JSON是Python的标准库，不需要额外安装。代码如下： 123456789import jsonfrom urllib.request import urlopendef getCountry(ipAddress): res = urlopen("http://freegeoip.net/json/"+ipAddress).read().decode('utf-8') resJson = json.loads(res) return resJson.get('country_code')print(getCountry("22.18.53.22")) Python 使用了一种更加灵活的方式，把 JSON 转换成字典，JSON 数组转换成列表,JSON 字符串转换成 Python 字符串。 正式邀请你免费加入我的星球，一起分享，共同成长。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
        <tag>数据采集</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络数据采集之创建爬虫|第02天]]></title>
    <url>%2Fposts%2F38026%2F</url>
    <content type="text"><![CDATA[主要内容： 单个域名和网站的采集； 互联网采集和用Scrapy采集初步介绍。 开始采集网络爬虫是可以根据递归方式。为了找到URL 链接，它们必须首先获取网页内容，检查这个页面的内容，再寻找另一个 URL，然后获取 URL对应的网页内容，不断循环这一过程。 遍历单个域名以抓取维基百科的Kevin Baco为例，实现简单的数据爬取。代码如下： 12345678from urllib.request import urlopenfrom bs4 import BeautifulSoup html = urlopen('http://en.wikipedia.org/wiki/Kevin_Bacon')bs = BeautifulSoup(html, 'html.parser')for link in bs.find_all('a'): if 'href' in link.attrs: print(link.attrs['href']) 上述代码就获取维基百科网站的任何页面并提取页面链接。去掉我们不需要的词条，进行改进获取词条链接。代码如下： 12345678910from urllib.request import urlopen from bs4 import BeautifulSoup import rehtml = urlopen('http://en.wikipedia.org/wiki/Kevin_Bacon')bs = BeautifulSoup(html, 'html.parser')for link in bs.find('div', &#123;'id':'bodyContent'&#125;).find_all( 'a', href=re.compile('^(/wiki/)((?!:).)*$')): if 'href' in link.attrs: print(link.attrs['href']) 如果我们要做到一个函数getLinks，可以用维基百科词条/wiki/&lt;词条名称&gt;形式的URL链接作为参数，然后以同样的形式返回一个列表，里面包含所有的词条 URL 链接。一个主函数，以某个起始词条为参数调用getLinks，再从返回的URL列表里随机选择一个词条链接，再调用 getLinks，直到我们主动停止，或者在新的页面上没有词条链接了，程序才停止运行。完善后代码如下： 1234567891011121314151617from urllib.request import urlopenfrom bs4 import BeautifulSoupimport datetimeimport randomimport rerandom.seed(datetime.datetime.now())def getLinks(articleUrl): html = urlopen('http://en.wikipedia.org&#123;&#125;'.format(articleUrl)) bs = BeautifulSoup(html, 'html.parser') return bs.find('div', &#123;'id':'bodyContent'&#125;).find_all('a', href=re.compile('^(/wiki/)((?!:).)*$'))links = getLinks('/wiki/Kevin_Bacon')while len(links) &gt; 0: newArticle = links[random.randint(0, len(links)-1)].attrs['href'] print(newArticle) links = getLinks(newArticle) 遍历整个网络采集整个网站，那是非常耗费内存资源的过程，尤其是处理大型网站时，最合适的工具就是用一个数据库来储存采集的资源。 遍历整个网络的数据好处：可以生产网站地图，收集网站数据等。但是一般不会消耗大量的内存资源去做采集，本节的意义不大。 通过互联网采集建立网络地图，需要从一个链接跳转到另一个链接，逐步建立网站的地图信息，从而达到一个合适的网站地图，于此同时我们也不能忽略外链，从一个链接跳转到另一个链接的场景也会时有发生。相比之前的单域名采集，互联网采集的难度要高很多，所以，要求我们的寻找信息的方式和采集信息的方式都应该极具灵活性，以此达到理想的采集效果。 在做数据采集之前最好能够确定自己采集的内容，明确目标，然后根据目标的展示形式去分析，该网站是否会跳转其他的链接，是否需要继续采集等各个因素。 如果采集一个网站，有时候也会考虑到网络重定向的问题，例如我的个人博客原来链接是：https://forestfdemo.github.io,但是我做了一个网络的重定向，我将https://chensenlin.cn，重定向到原来的链接，这样无论是访问哪一个链接其本质都跳转到原来的链接，此时需要了解的是网络重定向的时候，我们采集的URL地址会发生变化，在Python3.X的版本中，我们的urllib会帮我完成重定向的功能。 用Scrapy采集Scrapy就是一个可以大幅度降低我们对网页链接查找和识别工作复杂度的Python 库，它可以让你轻松地采集一个或多个域名的信息。 目前Scrapy仅支持Python 2.7，还不支持 Python 3.x。 利用Scrapy进行爬虫项目还是有一些设置，我们可以采用官网下载，也可以采用pip进行安装，检验安装的方法在之前的Python基础系列的文章有提到过。这里不做过多的阐述。 创建一个项目： 1234567➜ python scrapy startproject demourlNew Scrapy project 'demourl', using template directory '/usr/local/lib/python3.6/site-packages/scrapy/templates/project', created in: /Users/demo/Project/python/demourlYou can start your first spider with: cd demourl scrapy genspider example example.com 我们查看一下目录结构： 123456789101112131415➜ demourl tree ././├── [drwxr-xr-x] demourl│ ├── [-rw-r--r--] __init__.py│ ├── [drwxr-xr-x] __pycache__│ ├── [-rw-r--r--] items.py│ ├── [-rw-r--r--] middlewares.py│ ├── [-rw-r--r--] pipelines.py│ ├── [-rw-r--r--] settings.py│ └── [drwxr-xr-x] spiders│ ├── [-rw-r--r--] __init__.py│ └── [drwxr-xr-x] __pycache__└── [-rw-r--r--] scrapy.cfg4 directories, 7 files 关于Scrapy的内容我们后续逐一介绍，大家可以点击关注，及时收到后续更新。 正式邀请你免费加入我的星球，一起分享，共同成长。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
        <tag>数据采集</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络数据采集之HTML解析|第01天]]></title>
    <url>%2Fposts%2F40836%2F</url>
    <content type="text"><![CDATA[主要内容： BeautifulSoup使用和find()和find_all()； 正则表达式和BeautifulSoup结合使用； Lambda表达式介绍。 复杂的HTML解析思考后确定获取目标假如我们确定一个我们需要采集的目标信息，可能是一组统计数据、或者一个 title等，但是此时这个目标可能藏的比较深，可能在第20层的标签里面，你可能会用下面的方式去抓取： 1bsObj.findAll("table")[4].findAll("tr")[2].find("td").findAll("div")[1].find("a") 同时还有一个问题，加入网站发生细微的变化。我们的代码不仅影响美观还回影响整个爬虫网络。这样的情况我们应该怎么做呢？ 尝试“打印此页”的链接，或者看看该网页的移动版是够更加友好，请求的时候将请求头设置为移动端的状态。 寻找隐藏在JavaScript文件里的信息。网站的某些数据可能隐藏在JavaScript文件中。 可以试试其他的网站资源。 BeautifulSoup使用上一篇我们学会了如何安装和运行BeautifulSoup,现在我们逐步深入，学习通过属性查找标签的方法、标签组、标签解析树的导航过程。 每个网站都有层叠样式表(也就是我们说的CSS)，它对于爬虫而言有一个最大的好处就是能够让HTML元素表现出差异化。 例如某些标签是下面这样的： 1&lt;span class="green"&gt;&lt;/span&gt; 或者这样的： 1&lt;span class="red"&gt;&lt;/span&gt; 爬虫可以根据class的属性值去区分不同的标签。例如：我们可以只抓取红色的字。 下面我们以这个网站为例来创建一个网络爬虫。 通过上图可以知道红色的为对话正文部分，绿色为姓名的信息。现在可以创建一个简单的BeautifulSoup对象。 1234from urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen(" http://www.pythonscraping.com/pages/warandpeace.html")bsObj = BeautifulSoup(html,'lxml') # 获取了html的所有信息 通过BeautifulSoup对象，我们可以用findAll函数抽取只包含在&lt;span class=&quot;green&quot;&gt;&lt;/ span&gt;标签里的文字，这样就会得到一个人物名称的 Python列表。 1234nameList = bsObj.find_all('span',&#123;"class":"green"&#125;) #获取span标签的class为green的所有姓名for name in nameList:# 遍历取值 print(name.get_text()) 然后运行得到的就是所有的姓名列表。 get_text()使用场景主要是处理一个包含许多超链接、段落和标 签的大段源代码，它就会吧这些超链接和段落以及标签都清理掉。也就是说它会把你正在处理的 HTML文档中所有的标签都清除，然后返回一个只包含文字的字符串。 BeautifulSoup的find()和find_all()BeautifulSoup里的find()和find_all()可能是你最常用的两个函数。借助它们，你可以通过标签的不同属性轻松地过滤HTML页面,查找需要的标签组或单个标签。 BeautifulSoup文档地址：http://beautifulsoup.readthedocs.io find()函数语法： 1find( name , attrs , recursive , string , **kwargs ) find_all()函数语法： 1find_all( name , attrs , recursive , string , **kwargs ) 搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件。 name参数可以查找所有名字为name的tag,字符串对象会被自动忽略掉。搜索 name参数的值可以使任一类型的过滤器,字符串,正则表达式,列表,方法等。 attrs参数定义一个字典参数来搜索包含特殊属性的tag。 通过string参数可以搜搜文档中的字符串内容,与name参数的可选值一样。 keywork参数：如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字tag的属性来搜索。 find_all()方法返回全部的搜索结构,如果文档树很大那么搜索会很慢。如果我们不需要全部结果,可以使用 limit参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到limit的限制时,就停止搜索返回结果。 find 等价于 find_all 的 limit 等于 1 ; 调用tag的 find_all()方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=False。 其他BeautifulSoup对象NavigableString对象：表示标签里面的文字；Comment对象：用来查找HTML文档的注释标签。例如：&lt;!-- 注释 --&gt; 导航树导航树解决的问题是通过标签在文档中的位置来查找标签。以该网站为例。 第一类，处理子标签和其他后代标签。 子标签就是一个父标签的下一级，而后代标签是指一个父标签下面所有级别的标签。所有的子标签都是后代标签，但不是所有的后代标签都是子标签。例如：tr标签是tabel标签的子标签，而 tr、th、td、img和 span标签都是 tabel 标签的后代标签。 一般情况下，BeautifulSoup函数总是处理当前标签的后代标签。 例如根据示例网站我们需要找到文档中第一个div标签，然后获取这个div后代里面所有的img标签。 12345678from urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen('http://www.pythonscraping.com/pages/page3.html')bs = BeautifulSoup(html, 'html.parser')for child in bs.find('table',&#123;'id':'giftList'&#125;).children: print(child) 输出的结果就是打印 giftList 表格中所有产品的数据行。 第二类，处理兄弟标签。 BeautifulSoup的next_siblings()函数可以让收集表格数据成为简单的事情，尤其是处理带标题行的表格: 12345678from urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen('http://www.pythonscraping.com/pages/page3.html')bs = BeautifulSoup(html, 'html.parser')for sibling in bs.find('table', &#123;'id':'giftList'&#125;).tr.next_siblings: print(sibling) 输出的结果是打印产品列表里的所有行的产品，第一行表格标题除外。 第三类，父标签处理。 抓取网页的时候我们抓取父标签的情况比较少，但是不排除有这样的情况存在。例如，我们要观察网页的内容。这里就需要连个两个函数parent 和 parents。 12345678from urllib.requesturllib. import urlopenfrom bs4 import BeautifulSouphtml = urlopen('http://www.pythonscraping.com/pages/page3.html')bs = BeautifulSoup(html, 'html.parser')print(bs.find('img',&#123;'src':'../img/gifts/img1.jpg'&#125;).parent.previous_sibling.get_text()) 上述代码的结果是img1图片的价格。 正则表达式正则表达式个人认为比较简单，就跟学习英语一样，只要不断的去用就了解了。贴上原图可查阅即可。关于正则的相关基础知识可以看看我推荐的网站了解一下，或者可以关注我，后续专门写一个正则表达式入门的文章。 正则表达式30分钟入门教程：https://deerchao.net/tutorials/regex/regex.htm正则表达式书籍：https://luke0922.gitbooks.io/learnregularexpressionin30minutes/content/ 或者用下面的这张图，然后跟着去套一些例子。 正则表达式和BeautifulSoup结合正则表达式，来实现一下具体的例子，可能更容易理解一些。我们获取刚刚网站的所有图片，首先打开源码分析一下页面。 我们发现所有的图片都是以../img/gifts/img开头，以.jpg 结尾。那么就用正则去匹配一下。匹配规则如下： 1\.\.\/img\/gifts/img.*\.jpg 结合BeautifulSoup对象我们可以尝试用代码试一下： 123456789from urllib.request import urlopenfrom bs4 import BeautifulSoupimport rehtml = urlopen('http://www.pythonscraping.com/pages/page3.html')bs = BeautifulSoup(html, 'html.parser')images = bs.find_all('img', &#123;'src':re.compile('\.\.\/img\/gifts/img.*\.jpg')&#125;)for image in images: print(image['src']) 运行的结果： 123456➜ url python pareten2.py../img/gifts/img1.jpg../img/gifts/img2.jpg../img/gifts/img3.jpg../img/gifts/img4.jpg../img/gifts/img6.jpg 这就是网站的所有图片的相对路径，以后可以用这样的方法去匹配视频网站的路径，然后下载啦。 获取属性在网络数据采集时你经常不需要查找标签的内容，而是需要查找标签属性。比如标签 &lt;a&gt;指向 的 URL 链接包含在 href属性中，或者 &lt;img&gt;标签的图片文件包含在 src 属性中。 对于一个标签对象，可以用myTag.attrs获取它的全部属性,要注意这行代码返回的是一个 Python 字典对象，可以获取和操作这些属性。例如要获取图片的资源位置 src，可以用myImgTag.attrs[&quot;src&quot;]获取。 Lambda表达式Lambda表达式本质上是一个函数，可以作为其他函数的变量使用;也就是说，一个函数不是定义成 f(x, y)，而是定义成 f(g(x), y)，或 f(g(x), h(x)) 的形式。 BeautifulSoup 允许我们把特定函数类型当作 findAll 函数的参数。唯一的限制条件是这些函数必须把一个标签作为参数且返回结果是布尔类型。BeautifulSoup用这个函数来评估它遇到的每个标签对象，最后把评估结果为“真”的标签保留，把其他标签剔除。 正式邀请你免费加入我的星球，一起分享，共同成长。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据采集</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络数据采集之创建爬虫|第00天]]></title>
    <url>%2Fposts%2F26519%2F</url>
    <content type="text"><![CDATA[主要内容： 网络相关知识； BeautifulSoup介绍和使用。 说明开始本系列的文章时，可能你需要了解一下Python的基础知识，熟悉Python的基本编程，了解一些网络知识等。如果不是特别了解，可以看看我的Python基础系列文章。 创建爬虫网络链接网络浏览器是一个非常有用的应用，它创建信息的数据包，发送它们，然后把你获取的数据解释成漂亮的图像、声音、视频和文字。但是，网络浏览器就是代码，而代码是可以分解的，可以分解成许多基本组件，可重写、重用，以及做成我们想要的任何东西。网络浏览器可以让服务器发送一些数据，到那些对接无线(或有线)网络接口的应用上， 但是许多语言也都有实现这些功能的库文件。关于浏览器的相关介绍，可以参考维基关于浏览器的官方介绍。 Python实现抓取网页。新建文件为urllib_request.py。 1234# 查找 Python 的 request 模块(在 urllib 库里面)，并导入 urlopen 函数from urllib.request import urlopenhtml = urlopen("http://www.baidu.cn")print(html.read()) 执行： 1python urllib_request.py 在进行数据抓取时需要保证能够与该网页的连通性，可以尝试用ping的方式进行测试。这里我采用的是抓取百度的首页数据。返回的是百度首页的全部HTML代码。 urllib 是Python的标准库，包含了从网络请求数据，处理cookie，甚至改变像请求头和用户代理这些元数据的函数。urlopen用来打开并读取一个从网络获取的远程对象。urlib的文档地址。 标准库：不用额外安装的库就可以直接运行。 BeautifulSoup简介BeautifulSoup通过定位HTML标签来格式化和组织复杂的网络信息，用简单易用的Python对象为我们展现XML结构信息。 安装BeautifulSoupBeautifulSoup并不是标准库，所以需要通过安装后来使用。本人采用Mac的系统，同时已经安装了pip，所以直接可以采用pip来安装即可，不过需要注意版本问题。 Mac安装BeautifulSoup方法： 1pip install beautifulsoup4 如果没有报错可以验证一下是否安装成功。验证的方式有很多。这里我举例两种最常用的验证方式。 第一种验证方式：终端直接查看包是否存在。 1pip freeze | grep beautifulsoup4 如果输出：beautifulsoup4==4.6.0,表示已经有了，只不过版本可能会不一致，但是模块名是一致的。 第二种验证方式：进入python界面，然后倒入某一个函数看看是否报错，或者直接写代码执行一下。 123456➜ day0 pythonPython 3.6.4 (default, Mar 1 2018, 18:36:50)[GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; from bs4 import BeautifulSoup&gt;&gt;&gt; exit(); 综上所述，两种验证方式都通过了，说明现在已经安装完成且可以使用了。 这里的安装是全局安装，如果在实际开发中不同的项目可能会有不同的环境或者版本要求，甚至会产生冲突，现在就就需要的能够支持多种的环境的需求，可以用虚拟环境保存库文件。安装一个Python虚拟环境来分而治之。具体的使用方法这里不做过多阐述，后续会有对应的更新，你可以关注我就可以收到更新提示。 运行BeautifulSoup结合之前抓取百度首页的代码，现在针对某网站的某文件进行抓取。如下： 12345from urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen("http://www.pythonscraping.com/pages/page1.html") bsObj = BeautifulSoup(html.read(),'lxml')print(bsObj.h1) 运行后就得到了该网页的标题。如下： 12➜ day0 python request.py&lt;h1&gt;An Interesting Title&lt;/h1&gt; 这就是根据网页的源码得到了该网页的标题。未来可以通过正则等方式获取。 可靠的网络连接数据采集的问题在于保证程序与目标网站的服务器一直保持通信，否则的话爬虫就不会继续工作了。这个时候就需要进行网络异常处理。 例如我们上一节的代码中有下面一行代码： 1html = urlopen("http://www.pythonscraping.com/pages/page1.html") 这里面会出现两个问题，服务器不存在或者这个页面不存在。也就是要么404,要么500。 12345678try: html = urlopen("http://www.pythonscraping.com/pages/page1.html")except HTTPError as e: print(e) # 返回空值，中断程序，或者执行另一个方案 else: # 程序继续。注意:如果你已经在上面异常捕捉那一段代码里返回或中断(break)， # 那么就不需要使用else语句了，这段代码也不会执行 也有可能获取的时候，该html页面就是一个空的，是不是又需要增加判断呢？ 1234if html is None: print("URL is not found")else: # 程序继续 获取到了内容，是不是需要继续判断一下该内容是否为我们所需要的内容呢？所以需要增加一个检查标签是否存在判断。 最后我们的判断是不是看起来代码特别的累赘，我们简单整理一下后，代码如下： 1234567891011121314151617181920from urllib.request import urlopenfrom urllib.error import HTTPErrorfrom bs4 import BeautifulSoup def getTitle(url): try: html = urlopen(url) except HTTPError as e: return None try: bsObj = BeautifulSoup(html.read()) title = bsObj.body.h1 except AttributeError as e: return None return title title = getTitle("http://www.pythonscraping.com/pages/page1.html") if title == None: print("Title could not be found")else: print(title) 正式邀请你免费加入我的星球，一起分享，共同成长。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
        <tag>数据采集</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python常用函数整理]]></title>
    <url>%2Fposts%2F26518%2F</url>
    <content type="text"><![CDATA[主要内容： 字符串函数、集合函数、列表函数和字典函数。 Python常用函数字符串函数 方法 说明 capitalize() 返回首字母的大写副本 find(string) 返回字符串中首次出现参数string的索引，如果字符串中没有参数string则返回-1 find(s,beg) 返回字符串中索引beg之后首次出现参数s的索引，如果字符串中索引beg之后没有参数s则返回-1 find(s,beg,end) 返回字符串中索引beg与end之间首次出现参数s的索引，如果字符串中索引beg和end之间没有参数s则返回-1 islower() 测试所有字符是否均为小写形式 isupper() 测试所有字符是否均为大写形式 lower() 将所有字符穿华为小写形式并返回 replace(old,new) 将字符串中所有子串old替换为new并返回 split() 将空格分隔的单词以列表的形式返回 split(del) 将del分隔的子串以列表的形式返回 strip() 删除字符串两端的空白符并返回 strip(string) 删除字符串中的string并返回 upper() 将所有字符串转化为大写形式并返回 列表函数 方法 说明 len(L) 返回列表L中的元素数量 max(L) 返回列表L中的最大值 min(L) 返回列表L中的最小值 sum(L) 返回列表L中所有元素的和 集合函数 方法 运算符 说明 add 往集合中添加一个元素 clear 移除集合中的所有元素 difference - 根据一个集合中不存在于另一个集合中的元素，创建中一个新的集合 intersection &amp; 根据两个集合中共有的元素，创建出一个新的集合 issubset &lt;= 判断一个集合的所有元素是否都包含于另一个集合 issuperset &gt;= 判断一个集合是否包含了另一个集合中的所有元素 remove 移除集合中的一个元素 symmetric_difference ^ 根据两个集合中所有不存在于对方的元素，创建出一个新的集合 union 根据两个集合中所有的元素，创建出一个新的集合 字典函数 方法 说明 clear 清空字典内容 get 返回关键字所关联的值，如果指定键不存在，则返回默认值 keys 以列表的形式返回字典中的所有键。所得列表中的每个条目肯定是唯一的 items 返回（key,value）列表 values 以列表的形式返回字典中的所有值。所得列表中的每个条目不一定是唯一的 update 用另一个字典的内容对当前字典进行更新]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础学习09天]]></title>
    <url>%2Fposts%2F1508%2F</url>
    <content type="text"><![CDATA[主要内容： 文件处理相关，读取文件和写入文件等。 异常处理和捕获异常。 文件和异常处理从文件中读取数据要使用文本文件中的信息，首先需要将信息读取到内存中。为此，我们可以一次性读取文件的 全部内容，也可以以每次一行的方式逐步读取。 读取整个文件要读取文件，需要一个包含几行文本的文件。新建一个圆周率后30位的文件为例，保存为pi_digits.txt，同时小数点后是为换行。如下： 1233.1415926535 8979323846 2643383279 读取该文件的Python文件，file_reader.py。代码如下： 123with open('pi_digits.txt') as file_object: contents = file_object.read() print(rstrip(contents)) open()函数是任何方式使用文件，哪怕仅仅是打印其内容，都得先打开文件。它接受一个参数: 要打开的文件的名称。Python在当前执行的文件所在的目录中查找指定的文件。 close()函数是关闭文件。 关键字with在不再需要访问文件后将其关闭。Python方法rstrip()删除字符串末尾的空白。 运行结果： 1233.1415926535 8979323846 2643383279 文件路径当你将类似pi_digits.txt这样的简单文件名传递给函数open()时，Python将在当前执行的文件 (即.py程序文件)所在的目录中查找文件。 语法格式： 1with open('text_files/filename.txt') as file_object: 通过使用绝对路径，可读取系统任何地方的文件。注意区分相对路径和绝对路径。 逐行读取读取文件时，常常需要检查其中的每一行:你可能要在文件中查找特定的信息，或者要以 某种方式修改文件中的文本。逐行读取可以理解为遍历、循环等逻辑。所以在读取文件时，可以采用for语句来实现。代码示例： 12345filename = 'pi_digits.txt'with open(filename) as file_object: for line in file_object: print(line.rstrip()) 创建一个包含文件各行内容的列表使用关键字with时，open()返回的文件对象只在with代码块内可用。如果要在with代码块外 访问文件的内容，可在with代码块内将文件的各行存储在一个列表中，并在with代码块外使用该列表:你可以立即处理文件的各个部分，也可推迟到程序后面再处理。 1234567filename = 'pi_digits.txt'with open(filename) as file_object: lines = file_object.readlines()#从文件中读取每一行，并将其存储在一个列表中#使用一个简单 的for循环来打印lines中的各行for line in lines: print(line.rstrip()) 使用文件的内容将文件读取到内存中后，就可以以任何方式使用这些数据了。 12345678910filename = 'pi_digits.txt'with open(filename) as file_object: lines = file_object.readlines()#从文件中读取每一行，并将其存储在一个列表中pi_string = '' #创建一个变量存贮圆周率的值for line in lines: #使用一个循环将各行都加入pi_string，并删除每行末尾的换行符 pi_string += line.strip()print(pi_string) #打印这个字符串print(len(pi_string)) # 长度 读取文本文件时，Python将其中的所有文本都解读为字符串。如果你读取的是数字，并 要将其作为数值使用，就必须使用函数int()将其转换为整数，或使用函数float()将其转 换为浮点数。 包含一百万位的大型文件对于你可处理的数据量，Python没有任何限制;只要系统的内存足够多，想处理多少数据都可以。 写入文件保存数据的最简单的方式之一是将其写入到文件中。通过将输出写入文件，即便关闭包含程序输出的终端窗口，这些输出也依然存在:可以在程序结束运行后查看这些输出，可与别人分享输出文件，还可编写程序来将这些输出读取到内存中并进行处理。 写入空文件要将文本写入文件，你在调用open()时需要提供另一个实参，告诉Python你要写入打开的文件。 代码示例： 1234filename = 'programming.txt'with open(filename, 'w') as file_object: file_object.write("I love programming.") 打开文件时，可指定读取模 式(&#39;r&#39;)、写入模式(&#39;w&#39;)、附加模式(&#39;a&#39;)或让你能够读取和写入文件的模式(&#39;r+&#39;)。如果 你省略了模式实参，Python将以默认的只读模式打开文件。 以写入(‘w’)模式打开文件时,如果指定的文件已经存在，Python将在返回文件对象前清空该文件。 Python只能将字符串写入文本文件。要将数值数据存储到文本文件中，必须先使用函数str()将其转换为字符串格式。 写入多行函数write()不会在你写入的文本末尾添加换行符,如果需要写入多行就需要在每行的后面添加换行符：\n 。 12345filename = 'programming.txt'with open(filename, 'w') as file_object: file_object.write("I love programming.") file_object.write("I love Python.") 输入结果： 1I love programming.I love Python. 附加到文件附加到文件可以理解为不清空当前的文件内容，在文件内容后面追加即可。如果以附加的形式打开，如果文件不存在就会被创建。具体实现只需要在使用open()函数的时候指定打开方式为a即可，其余类似。 异常Python使用被称为异常的特殊对象来管理程序执行期间发生的错误。每当发生让Python不知 所措的错误时，它都会创建一个异常对象。 异常是使用try-except代码块处理的。try-except代码块让Python执行指定的操作，同时告诉Python发生异常时怎么办。使用了try-except代码块时，即便出现异常，程序也将继续运行: 显示你编写的友好的错误消息，而不是令用户迷惑的traceback。 处理ZeroDivisionError异常例如我们让Python运行8/0的代码报错信息。 1234&gt;&gt;&gt; 7/0Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ZeroDivisionError: division by zero 此时程序停止运行。 使用try-except代码块12345try: print(7/0) except ZeroDivisionError: print("You can't divide by zero!") # 其他的代码块将继续运行 使用异常避免崩溃发生错误时，如果程序还有工作没有完成，妥善地处理错误就尤其重要。这种情况经常会出 现在要求用户提供输入的程序中;如果程序能够妥善地处理无效输入，就能再提示用户提供有效输入，而不至于崩溃。 else代码块try-except-else代码块的工作原理:Python尝试执行try代码块中的代码;只有可 能引发异常的代码才需要放在try语句中。 代码示例： 123456try: answer = int(first_number) / int(second_number)except ZeroDivisionError: print("You can't divide by 0!")else: print(answer) 处理FileNotFoundError异常产生的背景：要查找的文件可能在其他地方、文件名可能 不正确或者这个文件根本就不存在。机会产生FileNotFoundError异常。同理可以给用户一个友好的消息提示。 拆分字符串方法split()以空格为分隔符将字符串分拆成多个部分，并将这些部分都存储到一个列表中。 代码示例： 123&gt;&gt;&gt; title = "Alice in Wonderland" &gt;&gt;&gt; title.split()['Alice', 'in', 'Wonderland'] 使用多个文件使用多个文件和单个文件逻辑一致，只不过把逻辑处理部分封装为方法，多个文件就循环处理即可。 1234567891011121314151617def count_words(filename): #计算一个文件大致包含多少个单词 try: with open(filename) as f_obj: contents = f_obj.read() except FileNotFoundError: msg = "Sorry, the file " + filename + " does not exist." print(msg) else: # 计算文件大致包含多少个单词 words = contents.split() num_words = len(words) print("The file " + filename + " has about " + str(num_words) +" words.")filename = 'alice.txt' count_words(filename) 存储数据模块json让你能够将简单的Python数据结构转储到文件中，并在程序再次运行时加载该文件 中的数据。你还可以使用json在Python程序之间分享数据。更重要的是，JSON数据格式并非Python专用的，这让你能够将以JSON格式存储的数据与使用其他编程语言的人分享。 使用json.dump()和json.load()函数json.dump()接受两个实参:要存储的数据以及可用于存储数据的文件对象。 编写一个存储一组数字的简短程序，再编写一个将这些数字读取到内存中的程序 (json.load())。 代码示例： 12345678910import jsonnum = [1,2,3,4,5,6]filename = 'num.json'with open(filename,'w') as f_obj: json.dump(num,f_obj)#写入文件 num = json.load(f_obj) #读到内存，可以打印 print(num) 运行后文件的内容和打印的内容一致。 1[1, 2, 3, 4, 5, 6] 保存和读取用户生成的数据用户输入的信息我们可以通过写入文件的方式写在文件内，再次输入的时候可以打开文件查询判断是否存在。其实就是把写入和读取文件两个逻辑合成一个。 代码如下： 12345678910111213import jsonfilename = 'username.json'try: with open(filename) as f_obj: username = json.load(f_obj)except FileNotFoundError: username = input("What is your name? ") with open(filename, 'w') as f_obj: json.dump(username, f_obj) print("We'll remember you when you come back, " + username + "!")else: print("Welcome back, " + username + "!")]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础学习08天]]></title>
    <url>%2Fposts%2F63973%2F</url>
    <content type="text"><![CDATA[主要内容： 类的基本介绍、创建和使用； 实例化类，设置属性和和修改等。 创建和使用类创建Dog类根据约定，在Python中，首字母大写的名称指的是类。 这个类定义中的括号是空的，因为我们要从空白创建这个类。类中的函数称为方法。 代码如下: 123456789101112class dog(): # 创建一个小狗的类 def _init_(self,name,age): # 初始化属性name和age self.name = name self.age = age def sit(self): # 模拟小狗被命令时蹲下 print(self.name.title() + " is now sitting !") def roll_over(self): # 打滚 print(self.name.title() + " rolled over!") __init__方法 __init__()是一个特殊的方法，每当你根据Dog类创建新实例时，Python都会自动运行它。在这个方法的名称中，开头和末尾各有两个下划线，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突。它包含了三个形参：self、name和age，在这个方法的定义中，形 参self必不可少，还必须位于其他形参的前面。 根据类创建实例可将类视为有关如何创建实例的说明。 代码示例: 123my_dog = Dog('demo',18)print(my_dog.name.title())print(my_dog.age) 访问属性 要访问实例的属性，可使用句点表示法。例如my_dog.name 调用方法 要调用方法，可指定实例的名称和要调用的方法，并用句点分隔它们。 代码示例： 123my_dog = Dog('demo', 6)my_dog.sit()my_dog.roll_over() 创建多个实例 12my_dog = Dog('demo', 6)you_dog = Dog('demo_go', 6) 使用类和实例类编写好后，你的大部分时间都将花在使用根据类创建的实例上。你需要执行的一个重要任务是修改实例的属性。你可以直接修改实例的属性，也可以编写方法以特定的方式进行修改。 Car类12345678910111213141516class Car(): # Car类 def __init__(self,name,model,year): # 初始化 self.name = name self.model = model self.year = year def get_descript(self): # 返回描述信息 long_name = str(self.year) + '---' + self.name + '---' + self.model return long_name.title() # 示例化my_car = Car('audi','A4','2016')print(my_car.get_descript()) 处理的结果是: 12016---Audi---A4 给属性设置默认值类中的每个属性都必须有初始值，哪怕这个值是0或空字符串。在有些情况下，如设置默认值时，在方法__init__()内指定这种初始值是可行的;如果你对某个属性这样做了，就无需包含为它提供初始值的形参。 在car类在__init__的方法新增属性self.odometer_reading = 0，同时新增一个方法read_odometer()： 123def read_odometer(self): # 打印一条指出汽车里程的消息 print("汽车的里程有：" + str(self.odometer_reading)) 调用该方法: 123my_car = Car('audi','A4','2016')print(my_car.get_descript())my_car.read_odometer() 修改属性的值可以以三种不同的方式修改属性的值：直接通过实例进行修改;通过方法进行设置;通过方法进行递增(增加特定的值)。 直接修改属性的值 代码如下： 1my_new_car.odometer_reading = 23 my_new_car.read_odometer() 有时候需要像这样直接访问属性，但其他时候需要编写对属性进行更新的方法。 通过方法修改属性的值 在Car类新增一个update_odometer()的方法，专门用来修改属性的值。 代码如下： 123def update_odometer(self,update_value): # 修改里程值 self.odometer_reading = update_value 在调用的时候就很简单了: 12my_new_car.update_odometer(66)my_new_car.read_odometer() 通过方法对属性的值进行递增 递增的逻辑其实很简单，只有将之前的记录保存并且和后面传入的值进行相加操作即可。 代码如下： 123def update_odometer(self,update_value): # 修改里程值 self.odometer_reading += update_value 调用方法： 1234my_new_car.update_odometer(6)my_new_car.read_odometer()my_new_car.update_odometer(1)my_new_car.read_odometer() 继承编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承。一个类继承另一个类时，它将自动获得另一个类的所有属性和方法;原有的类称为父类，而新类称为子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。 子类的方法__init__()创建子类的实例时，Python首先需要完成的任务是给父类的所有属性赋值。我们直接在上一节的汽车类基础上添加一个ElectricCar类，让它继承Car类。 123456789class ElectricCar(Car): # 电动汽车 def __init__(self,name,model,year): # 初始化父类的属性 super().__init__(name,model,year) # 示例化my_car = ElectricCar('dian', 'models', 2019)print(my_tesla.get_descriptive()) super()是一个特殊函数，帮助Python将父类和子类关联起来。这行代码让Python调用ElectricCar的父类的方法__init__()，让ElectricCar实例包含父类的所有属性。父类也称为超 类(superclass)，super因此而得名。 给子类定义属性和方法 让一个类继承另一个类后，可添加区分子类和父类所需的新属性和方法。和之前的定义属性和方法的逻辑类似，不做过多的阐述。可以理解为在子类里面可以自定义一些自己需要的方法或者属性。 重写父类的方法对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。或者可以理解为在子类里面可以重写一个新的方法，重新赋值一个新的属性等。通俗的理解为：“取其精华，去其糟粕”。 将实例用作属性使用代码模拟实物时，你可能会发现自己给类添加的细节越来越多:属性和方法清单以及文 件都越来越长。在这种情况下，可能需要将类的一部分作为一个独立的类提取出来。你可以将大 型类拆分成多个协同工作的小类。 导入类导入单个类为了使项目代码的可读性更加高，使用该模块的程序都必须使用更具体的文件名。例如my_car.py。导入的方法和之前类似，具体语法结构如下： 1from model_name import Class_name 采用improt语句让Python打开模块car，并导入其中的Car类，剩下的就可以使用了。 导入类是一种有效的编程方式。如果在这个程序中包含了整个Car类，它该有多长呀!通过 将这个类移到一个模块中，并导入该模块，你依然可以使用其所有功能，但主程序文件变得整洁而易于阅读。 在一个模块中存储多个类也就是一个模块中可以有多个类，例如父类和子类。假设my_car.py有两个类，一个是父类Car，另一个是子类ElectricCar，那么在导入该模块时，可以选择导入某一个类。 代码示例： 1from model_name import Class_name 现在就可以进行示例化或者其他的操作了。 从一个模块中导入多个类和我们之前导入函数的时候原理一样，我们可以导入任意数量的类。导入模块多个类的时候，采用逗号拼接即可。语法如下： 1from model_name import Class_name0, Class_name1 导入之后，就可根据需要创建每个类的任意数量的实例。 导入整个模块导入整个模块的语法也特别的简单，具体如下： 1import model_name 这样就可以使用整个模块的任意类。 导入模块中的所有类导入多个就用逗号一个个区分，然后倒入所有的就用*代替。所以语法如下： 1from model_name import * 引用原文。 不推荐使用这种导入方式，其原因有二。首先，如果只要看一下文件开头的import语句，就能清楚地知道程序使用了哪些类，将大有裨益;但这种导入方式没有明确地指出你使用了模块中的哪些类。这种导入方式还可能引发名称方面的困惑。如果你不小心导入了一个与程序文件中其 他东西同名的类，将引发难以诊断的错误。这里之所以介绍这种导入方式，是因为虽然不推荐使 用这种方式，但你可能会在别人编写的代码中见到它。 需要从一个模块中导入很多类时，最好导入整个模块，并使用module_name.class_name语法来访问类。这样做时，虽然文件开头并没有列出用到的所有类，但你清楚地知道在程序的哪些地方使用了导入的模块;你还避免了导入模块中的每个类可能引发的名称冲突。 在一个模块中导入另一个模块有时候，需要将类分散到多个模块中，以免模块太大，或在同一个模块中存储不相关的类。将类存储在多个模块中时，你可能会发现一个模块中的类依赖于另一个模块中的类。在这种情况下，可在前一个模块中导入必要的类。 这部分的笔记实在是比较简单，没有过多的代码，逻辑上的问题基本在之前都涉及过了。如果不是特别了解，可以看看之前的文章，或者可以关注我，后续将继续更新。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础学习07天]]></title>
    <url>%2Fposts%2F60902%2F</url>
    <content type="text"><![CDATA[主要内容： 函数的定义和使用； 传递实参和返回值； 模块的导入、使用和函数导入、使用。 函数函数是带名字的代码块，用于完 成具体的工作。要执行函数定义的特定任务，可调用该函数。需要在程序中多次 执行同一项任务时，你无需反复编写完成该任务的代码，而只需调用 执行该任务的函数，让Python运行其中的代码。 定义函数定义函数的关键字：def，由此来告诉Python这是一个函数。 代码示例： 123456def hello_user(): "函数体说明部分" mes = "你好我是森林" print(mes) hello_user() def关键字定义函数；hello_user()是该函数的函数名；冒号定义结尾；冒号后面到缩进结尾表示该函数的函数体，也就是函数需要做什么。上述函数就是打印一个变量。执行结果为：你好我是森林。而最后一行表示调用函数名为hello_user()的函数。 向函数传递信息在函数名后面的括号可以进行传参操作，例如传入简单的用户名。 代码示例： 12345def get_user(username): """用户信息""" print("我的名字叫: " + username) get_user("你好我是森林") 执行结果： 1我的名字叫：你好我是森林 实参和形参方法在定义的时候的参数称为形参，函数完成其工作所需的一项信 息；函数在调用的时候传入的参数称为实参。 例如在上面的代码中，get_user(username)的username未形参，而调用的时候输入你好我是森林`为实际参数。 传递实参鉴于函数定义中可能包含多个形参，因此函数调用中也可能包含多个实参。向函数传递实参的方式很多，可使用位置实参，这要求实参的顺序与形参的顺序相同;也可使用关键字实参，其中每个实参都由变量名和值组成;还可使用列表和字典。 位置实参调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。为此，最简单的关联方式是基于实参的顺序。这种关联方式被称为位置实参。 12345def get_user(type,value): """用户信息""" print("我的" + type + "是: " + value) get_user("年龄",'18') 根据type的类型传入的值，输入不一样的结果。传入的年龄就存入函数的type变量中，88就存入value变量中。这样就能够完整的输出。结果为：我的年龄是: 88。 根据这个结果可以推出，该函数可以被多次调用。例如： 12345678def get_user(type,value): """用户信息""" print("我的" + type + "是: " + value) get_user("年龄",'18')get_user("体重",'100')get_user("身高",'180')get_user("性别",'男') 输出的结果是： 1234我的年龄是: 18我的体重是: 100我的身高是: 180我的性别是: 男 需要注意的是传参的位置很重要。如果传参顺序出错，就容易出现笑话。 例如: 12345678def get_user(type,value): """用户信息""" print("我的" + type + "是: " + value) get_user("年龄",'18')get_user("100",'体重')get_user("100",'身高')get_user("男",'性别') 运行的结果： 1234我的年龄是: 18我的100是: 体重我的100是: 身高我的男是: 性别 关键字实参关键字实参是传递给函数的名称—值对。直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆。关键字实参让你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。 代码示例： 123456def get_user(type,value): """用户信息""" print("我的" + type + "是: " + value) get_user("年龄",'18')get_user(value="18",type = 'age') 运行结果 12我的年龄是: 18我的age是: 18 默认值编写函数时，可给每个形参指定默认值。在调用函数中给形参提供了实参时，Python将使用 指定的实参值;否则，将使用形参的默认值。因此，给形参指定默认值后，可在函数调用中省略相应的实参。使用默认值可简化函数调用，还可清楚地指出函数的典型用法。 代码示例： 123456def get_user(type,value = '19'): """用户信息""" print("我的" + type + "是: " + value) get_user("年龄",'18')get_user("年龄") #没有传值 运行结果： 12我的年龄是: 18我的年龄是: 19 使用默认值时，在形参列表中必须先列出没有默认值的形参，再列出有默认值的实参。 这让Python依然能够正确地解读位置实参。 等效的函数调用鉴于可混合使用位置实参、关键字实参和默认值，通常有多种等效的函数调用方式。基于这种定义，在任何情况下都必须给函数提供实参;指定该实参时可以使用位置方式，也可以使用关键字方式。同样，指定该实参时可以使用位置方式，也可以使用关键字方式。 返回值函数并非总是直接显示输出，相反，它可以处理一些数据，并返回一个或一组值。函数返回 的值被称为返回值。在函数中，可使用return语句将值返回到调用函数的代码行。返回值让你能够将程序的大部分繁重工作移到函数中去完成，从而简化主程序。 返回简单值代码示例： 1234567def get_user_info(type,info): """返回用户信息""" user_info = "我的" + type + "是: " + info return user_info.title()user_info = get_user_info('身高','190')print(user_info) 运行结果： 1我的身高是: 190 返回一条字符串类型的用户的信息，然后赋值给变量user_info，最后打印输出。 让实参变成可选的在某些时候我们的参数可能不是必选，但是需要设置默认值就可以决定是否需要传参。 返回字典将用户的信息存储在字典中。 1234567def build_person(first_name, last_name): """返回一个字典，其中包含有关一个人的信息""" person = &#123;'first': first_name, 'last': last_name&#125; return personmusician = build_person('jimi', 'hendrix')print(musician) 同时该字典还可以不断的增加。例如新增返回年龄。 调用函数： 123456789def build_person(first_name, last_name,age=''): """返回一个字典，其中包含有关一个人的信息""" person = &#123;'first': first_name, 'last': last_name&#125; if age: person['age'] = age return person musician = build_person('jimi', 'hendrix',age=19)print(musician) 返回结果： 1&#123;'first': 'jimi', 'last': 'hendrix', 'age': 19&#125; 传递列表向函数传递列表很有用，这种列表包含的可能是名字、数字或更复杂的对象(如字典)。将列表传递给函数后，函数就能直接访问其内容。 代码示例： 1234567def greet_users(names): """向列表中的每位用户都发出简单的问候""" for name in names: msg = "Hello, " + name + "!" print(msg)usernames = ['Hannah', 'Ty', 'Margot'] greet_users(usernames) 传入一个列表，进行循环遍历打印，然后得到如下结果。 运行结果： 123Hello, Hannah!Hello, Ty!Hello, Margot! 在函数中修改列表由上面的例子可以得出，函数在遍历的过程中是可以通过一些函数进行修改的。例如将传入的值全部变为大写。代码如下： 1234567def greet_users(names): """向列表中的每位用户都发出简单的问候""" for name in names: msg = "Hello, " + name.upper() + "!" print(msg)usernames = ['hannah', 'ty', 'margot'] greet_users(usernames) 当然，也可以进行复杂的修改操作。例如把传入的列表复制给第二个列表；同样，我们也可以紧致修改列表。 禁止函数修改列表将列表的副本传递给函数就可以实现没有修改列表。切片表示法[:]创建列表的副本。语法如下： 1function_name(list_name[:]) 传递任意数量的实参利用*定义为一个空元组就可以将所有传入的实参都进行打印。例如： 123456def make_pizza(*toppings): """打印顾客点的所有配料""" print(toppings) make_pizza('pepperoni')make_pizza('mushrooms', 'green peppers', 'extra cheese') 无论传入多少值都可以被打印出来。 结合使用位置实参和任意数量实参如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。`Python·先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。 12345678def make_pizza(size, *toppings): """概述要制作的比萨""" print("\nMaking a " + str(size) + "-inch pizza with the following toppings:") for topping in toppings: print("- " + topping) make_pizza(16, 'pepperoni')make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese') 使用任意数量的关键字实参有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键—值对——调用语句提供了多少就接受多少。只要坚持一个原则，无论用户输入的实参有多少信息，采用遍历的方式将其逐步返回，然后打印就可以实现无论用户输入什么信息就返回。 将函数存储在模块中函数的优点之一是，使用它们可将代码块与主程序分离。通过给函数指定描述性名称，可让 主程序容易理解得多。你还可以更进一步，将函数存储在被称为模块的独立文件中，再将模块导入到主程序中。import语句允许在当前运行的程序文件中使用模块中的代码。 导入整个模块要让函数是可导入的，得先创建模块。模块是扩展名为.py的文件，包含要导入到程序中的代码。创建模块代码示例： 123456def make_pizza(size, *toppings): """概述要制作的比萨""" print("\nMaking a " + str(size) + "-inch pizza with the following toppings:") for topping in toppings: print("- " + topping) 保存为make_pizza.py的文件，然后创建一个新的文件make.py。代码如下： 123import make_pizzamake_pizza.make_pizza(16, 'pepperoni') 运行后结果如下： 123➜ day8 python make.pyMaking a 16-inch pizza with the following toppings:- pepperoni 导入模块的某些函数既然可以导入整个模块，说明是能完全读取整个模块的信息，同理，可以推出，我们导入文件的时候是不是可以将某些函数导入进入使用呢？具体的语法如下： 导入某一个函数： 1from module_name import function_name 导入某些函数，也就是多个函数： 1from module_name import function_0, function_1, function_2 具体的使用方法同理，相当于该函数就可以被调用，和函数调用一致，没有什么区别。即： 123from pizz import make_pizzmake_pizz(12,'demo_pizz') 使用as给函数指定别名某些业务的需求，函数名可能有特别长，但是在新的模块文件中，我们不需要这样的函数名，一来影响代码的美观；二来对开发人员不太友好，于是采用关键字as可以给函数取一个在新的模块中的别名。具体的语法如下： 1from module_name import function_name as fun_name 在这里可以看到fun_name就是起的别名，在调用的时候就可以直接采用fun_name进行调用。具体调用方法如下： 123from pizz import make_install_pizz_div as mpipmpip(14,'pizz_name') 具体的调用和实际导入的函数没有什么区别，同样的使用。但是为了提高代码的可读性，建议最好将别名取的有意义。 使用as给模块指定别名由使用as给函数指定别名可以推出，同样可以为模块取一个更有意义或者更适合自己的别名。在日常的Python开发中，常用的库或模块有很多，我们同样可以进行别名的方式来实现。具体语法如下： 1import module_name as mn 使用方式不再阐述，和没有指定别名的方式是一样的。 导入模块中的所有函数在日常开发中*通常是通配符的意思，所以我们要实现一个导入模块的所有函数可以用*来实现。具体语法如下： 1from module_name import * 调用对应函数的方法和上面类似，不做过多的阐述。 函数编写指南 原文内容。 编写函数时，需要牢记几个细节。应给函数指定描述性名称，且只在其中使用小写字母和下划线。描述性名称可帮助你和别人明白代码想要做什么。给模块命名时也应遵循上述约定。 每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式。文档良好的函数让其他程序员只需阅读文档字符串中的描述就能够使用它:他们完全可以相信代码如描述的那样运行;只要知道函数的名称、需要的实参以及返回值的类型，就能在自己的程序中使用它。 给形参指定默认值时，等号两边不要有空格。PEP 8建议代码行的长度不要超过79字符，这样 只要编辑器窗口适中，就能看到整行代码。如果形参很多，导致函数定义的长度超过了79字符，可在函数定义中输入左括号后按回车键，并在下一行按两次Tab键，从而将形参列表和只缩进一层的函数体区分开来。大多数编辑器都会自动对齐后续参数列表行，使其缩进程度与你给第一个参数列表行指定的 缩进程度相同: 如果程序或模块包含多个函数，可使用两个空行将相邻的函数分开，这样将更容易知道前一个函数在什么地方结束，下一个函数从什么地方开始。所有的import语句都应放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整个程序。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础学习06天]]></title>
    <url>%2Fposts%2F4583%2F</url>
    <content type="text"><![CDATA[主要内容： 用户输入和while循环； 利用while处理列表和字典。 用户输入和while循环函数input()的工作原理函数input()让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在 一个变量中，以方便你使用。 代码示例: 12input_res = input("输入你最喜欢的食物:")print(input_res) 编写清晰的程序有时候，提示可能超过一行，例如，你可能需要指出获取特定输入的原因。在这种情况下， 可将提示存储在一个变量中，再将该变量传递给函数input()。 代码示例: 1234prompt = "If you tell us who you are, we can personalize the messages you see."prompt += "\nWhat is your first name? "name = input(prompt)print("\nHello, " + name + "!") 第1行将消息的前半部分存储在变量prompt中; 在第2行中，运算符+=在存储在prompt中的字符串末尾附加一个字符串。 使用int()来获取数值输入使用函数input()时，Python将用户输入解读为字符串。如果用户输入的值需要进行和数字比较，就会发生错误，这个时候就需要转换一下。可以采用int()来进行字符串和整型之间的转换 代码示例:1234567age = input("请输入你的年龄: ")age = int(age)if age &gt;= 18: print("你已经成年")else: print("你还未成年") 运行示例: 123456➜ day6 python int.py请输入你的年龄: 12你还未成年➜ day6 python int.py请输入你的年龄: 18你已经成年 求模运算符处理数值信息时，求模运算符(%)是一个很有用的工具，它将两个数相除并返回余数。求模运算符不会指出一个数是另一个数的多少倍，而只指出余数是多少。如果一个数可被另一个数整除，余数就为0，因此求模运算符将返回0。 代码示例: 123456&gt;&gt;&gt; 4 % 31&gt;&gt;&gt; 5 % 10&gt;&gt;&gt; 4 % 20 利用这一点来判 断一个数是奇数还是偶数: 123456number = input("Enter a number, and I'll tell you if it's even or odd: ") 13 number = int(number) if number % 2 == 0: print("\nThe number " + str(number) + " is even.")else: print("\nThe number " + str(number) + " is odd.") while 循环简介for循环用于针对集合中的每个元素都一个代码块，而while循环不断地运行，直到指定的条 件不满足为止。 使用while循环1234current_number = 1while current_number &lt;= 5: print(current_number) current_number += 1 在第1行，我们将current_number设置为1，从而指定从1开始数。接下来的while循环被设置 成这样:只要current_number小于或等于5，就接着运行这个循环。循环中的代码打印 current_number的值，再使用代码current_number += 1(代码current_number = current_number + 1的简写)将其值加1。只要满足条件current_number &lt;= 5，Python就接着运行这个循环。 让用户选择何时退出123456prompt = "\nTell me something, and I will repeat it back to you:"prompt += "\nEnter 'quit' to end the program. "message = "" while message != 'quit': message = input(prompt) print(message) 只有当用户输入quit的时候才能推出，否者一直不能退出。 采用标志在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于活动状态。这个变量被称为标志，充当了程序的交通信号灯。你可让程序在标志为True时继续运 行，并在任何事件导致标志的值为False时让程序停止运行。这样，在while语句中就只需检查一 个条件——标志的当前值是否为True，并将所有测试(是否发生了应将标志设置为False的事件) 都放在其他地方，从而让程序变得更为整洁。 使用break退出循环要立即退出while循环，不再运行循环中余下的代码，也不管条件测试的结果如何，可使用break语句。break语句用于控制程序流程，可使用它来控制哪些代码行将执行，哪些代码行不执行，从而让程序按你的要求执行你要执行的代码。 在循环中使用continue要返回到循环开头，并根据条件测试结果决定是否继续执行循环，可使用continue语句，它 不像break语句那样不再执行余下的代码并退出整个循环。 避免无限循环每个while循环都必须有停止运行的途径，这样才不会没完没了地执行下去。每一个循环必须要有一个可结束的条件。 使用while循环来处理列表和字典for循环是一种遍历列表的有效方式，但在for循环中不应修改列表，否则将导致Python难以跟踪其中的元素。要在遍历列表的同时对其进行修改，可使用while循环。通过将while循环同列表和字典结合起来使用，可收集、存储并组织大量输入，供以后查看和显示。主要的处理有：在列表之间移动元素；删除包含特定值的所有列表元素；使用用户输入来填充字典等。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础学习05天]]></title>
    <url>%2Fposts%2F21991%2F</url>
    <content type="text"><![CDATA[主要内容： 字典的介绍和基本使用； 遍历字典和字典嵌套相关知识； 字典及其使用在Python中，字典是一系列键—值对。每个键都与一个值相关联，你可以使用键来访问与之 相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。事实上，可将任何Python对 象用作字典中的值。在Python中，字典用放在花括号{}中的一系列键—值对表示。键—值对是两个相关联的值。指定键时，Python将返回与之相关联的值。键和值之间用冒号 分隔，而键—值对之间用逗号分隔。在字典中，你想存储多少个键—值对都可以。最简单的字典只有一个键—值对。 123alien_0 = &#123;'color': 'green', 'points': 5&#125;print(alien_0['color']) print(alien_0['points']) 访问字典的值要获取与键相关联的值，可依次指定字典名和放在方括号内的键。 12alien_0 = &#123;'color': 'green'&#125;print(alien_0['color']) 字典中可包含任意数量的键—值对。 1alien_0 = &#123;'color': 'green', 'points': 5&#125; 添加键-值对字典是一种动态结构，可随时在其中添加键—值对。要添加键—值对，可依次指定字典名、用 方括号括起的键和相关联的值。 1234alien_0 = &#123;'color': 'green', 'points': 5&#125;print(alien_0)alien_0['y_position'] = 25print(alien_0) 运行结果: 12&#123;'color': 'green', 'points': 5&#125; 13&#123;'color': 'green', 'points': 5, 'y_position': 25&#125; 注意，键—值对的排列顺序与添加顺序不同。Python不关心键—值对的添加顺序， 而只关心键和值之间的关联关系。 创建一个空字典方法：用一对空的花括号定义一个字典，再分行添加各个键—值对。使用字典来存储用户提供的数据或在编写能自动生成大量键—值对的代码时，通常都需要先 定义一个空字典。 代码: 123alien_0 = &#123;&#125;alien_0['color'] = 'green' alien_0['points'] = 5print(alien_0) 结果: 1&#123;'color': 'green', 'points': 5&#125; 修改字典中的值要修改字典中的值，可依次指定字典名、用方括号括起的键以及与该键相关联的新值。 代码示例: 1234alien_0 = &#123;'color': 'green'&#125;print("The alien is " + alien_0['color'] + ".")alien_0['color'] = 'yellow'print("The alien is now " + alien_0['color'] + ".") 运行结果: 12The alien is green.The alien is now yellow. 删除键—值对对于字典中不再需要的信息，可使用del语句将相应的键—值对彻底删除。使用del语句时， 必须指定字典名和要删除的键。 123alien_0 = &#123;'color': 'green', 'points': 5&#125;print(alien_0)del alien_0['points'] print(alien_0) 遍历字典一个Python字典可能只包含几个键—值对，也可能包含数百万个键—值对。鉴于字典可能包含 大量的数据，Python支持对字典遍历。字典可用于以各种方式存储信息，因此有多种遍历字典的 方式:可遍历字典的所有键—值对、键或值。 遍历所有的键-值对123456789user_0 = &#123; 'username': 'efermi', 'first': 'enrico', 'last': 'fermi',&#125;for key, value in user_0.items(): print("\nKey: " + key) print("Value: " + value) for语句的第二部分包含字典名和方法items()，它返回一个键—值对列表。 遍历字典中的所有键keys()获取字典的所有值。 代码示例: 12345678favorite_languages = &#123; 'jen': 'python', 'sarah': 'c', 'edward': 'ruby', 'phil': 'python', &#125;for name in favorite_languages.keys(): print(name) 运行结果: 1234jensarahedwardphil 遍历字典中的所有值values()获取字典的所有值。set()可以去除重复的值。 代码示例: 123456789101112favorite_languages = &#123; 'jen': 'python', 'sarah': 'c', 'edward': 'ruby', 'phil': 'python', &#125;for name in favorite_languages.values(): print(name)print("去重复的值")for name in set(favorite_languages.values()): print(name) 运行结果: 12345678pythoncrubypython去重复的值pythoncruby 嵌套有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为嵌套。可以在列表中嵌套字典、在字典中嵌套列表甚至在字典中嵌套字典。 字典列表代码示例: 12345678alien_0 = &#123;'color': 'green', 'points': 5&#125;alien_1 = &#123;'color': 'yellow', 'points': 10&#125;alien_2 = &#123;'color': 'red', 'points': 15&#125;aliens = [alien_0, alien_1, alien_2]for alien in aliens: print(alien) 运行结果: 123&#123;'color': 'green', 'points': 5&#125;&#123;'color': 'yellow', 'points': 10&#125;&#123;'color': 'red', 'points': 15&#125; 在字典中存储列表每当需要在字典中将一个键关联到多个值时，都可以在字典中嵌套一个列表。 代码示例: 1234pizza = &#123; 'crust': 'thick', 'toppings': ['mushrooms', 'extra cheese'], &#125; 列表和字典的嵌套层级不应太多。如果嵌套层级比前面的示例多得多，很可能有更简单 的解决问题的方案。 在字典中存储字典代码示例: 1234567891011users = &#123; 'aeinstein': &#123; 'first': 'albert', 'last': 'einstein', 'location': 'princeton', &#125;, 'mcurie': &#123; 'first': 'marie', 'last': 'curie', 'location': 'paris', &#125;,&#125; 首先定义了一个名为users的字典，其中包含两个键:用户名&#39;aeinstein&#39;和&#39;mcurie&#39;; 与每个键相关联的值都是一个字典，其中包含用户的名、姓和居住地。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础学习04天]]></title>
    <url>%2Fposts%2F43494%2F</url>
    <content type="text"><![CDATA[主要内容：条件判断和if语句的使用； 认识条件判断在日常开发中需要用到如果怎么样就怎么样，否则就怎么样的逻辑。主要采用if语句来实现的。 例如：假设你有一个汽车 列表，并想将其中每辆汽车的名称打印出来。对于大多数汽车，都应以首字母大写的方式打印其 名称，但对于汽车名&#39;bmw&#39;，应以全大写的方式打印。下面的代码遍历一个列表，并以首字母大 写的方式打印其中的汽车名，但对于汽车名&#39;bmw&#39;，以全大写的方式打印: 123456cars = ['audi', 'bmw', 'subaru', 'toyota']for car in cars: if car == 'bmw': print(car.upper()) else: print(car.title()) 运行结果: 1234AudiBMWSubaruToyota 条件测试每条if语句的核心都是一个值为True或False的表达式，这种表达式被称为条件测试。 判断是否相等相等的语句是:==，赋值的语句是:=，两者需要作区分。 12c = 'like'print(c == 'Like') 运行结果:False 如果需要或略大小写可以采用将其转化为小写的方式，函数为:lower()。其余的逻辑同理。 判断是否不相等语句:!=，其余的逻辑类似，不过多阐述。 比较数字 条件语句中可包含各种数学比较，如小于、小于等于、大于、大于等于。 代码示例： 123456&gt;&gt;&gt; num = 29&gt;&gt;&gt; num &lt; 21False&gt;&gt;&gt; num &gt;= 4True&gt;&gt;&gt; 多个条件判断多个条件判断将条件采用关键字and连接，只有全部为true才能满足，否则整体条件就为false。如果是或者的关系采用关键字or，只要满足其中的一个整体条件就为true。如果不确定优先级(或者可读性)的问题，可以采用括号就没个单个条件括起来。 代码示例： 1234567891011121314&gt;&gt;&gt; age_0 = 22 &gt;&gt;&gt; age_1 = 18&gt;&gt;&gt; age_0 &gt;= 21 and age_1 &gt;= 21 False&gt;&gt;&gt; age_1 = 22&gt;&gt;&gt; age_0 &gt;= 21 and age_1 &gt;= 21 True&gt;&gt;&gt; age_0 = 22 &gt;&gt;&gt; age_1 = 18&gt;&gt;&gt; age_0 &gt;= 21 or age_1 &gt;= 21 True&gt;&gt;&gt; age_0 = 18&gt;&gt;&gt; age_0 &gt;= 21 or age_1 &gt;= 21 &gt;&gt;&gt; False 采用括号的形式提高可读性和解决优先级的问题。 1(age_0 &gt;= 21) and (age_1 &gt;= 21) 检查特定的值是否包含在列表中要判断特定的值是否已包含在列表中，可使用关键字in。 代码示例： 12345&gt;&gt;&gt; requested_toppings = ['mushrooms', 'onions', 'pineapple']&gt;&gt;&gt; 'mushrooms' in requested_toppingsTrue&gt;&gt;&gt; 'pepperoni' in requested_toppingsFalse 检查特定的值是否不包含在列表中确定特定的值未包含在列表中，可使用关键字not in。 使用方法和上面判断是否在列表中一致。 布尔表达式布尔表达式的结果要么为True，要么为False,布尔值通常用于记录条件。 if语句简单的if语句代码示例: 123num = 34if num &gt;= 18: print("恭喜，您已经成年") if-else语句代码示例: 12345num = 16if num &gt;= 18: print("恭喜，您已经成年")else: print("你好，你未成年呢") if-elif-else 结构1234567num = 16if num &gt;= 18: print("恭喜，您已经成年")elif num &gt; 15: print("你好，还差3年就成年")else: print("122") elif可以连续多次使用，多加判断即可。同时在某些时候可以省略else的部分。 使用if语句处理列表检查特殊元素1234567requested_toppings = ['mushrooms', 'green peppers', 'extra cheese']for requested_topping in requested_toppings: if requested_topping == 'green peppers': print("Sorry, we are out of green peppers right now.") else: print("Adding " + requested_topping + ".")print("\nFinished making your pizza!") 循环的时候可以进行判断，然后即可，同时还可以判断是否为空列表。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础学习03天]]></title>
    <url>%2Fposts%2F56807%2F</url>
    <content type="text"><![CDATA[主要内容： 使用列表：切片，遍历切片，复制切片； 元组的定义，遍历元组，修改元组变量； 使用列表切片要创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数range()一样，Python 在到达你指定的第二个索引前面的元素后停止。要输出列表中的前三个元素，需要指定索引0~3， 这将输出分别为0、1和2的元素。 代码示例: 123456players = ['charles', 'martina', 'michael', 'florence', 'eli']print(players[0:3]) # 取从索引0开始到第三个结束，最后输出前三个print(players[0:3]) # 输出从索引1到4结束，print(players[:4]) # 没有索引就从列表开头开始，到指定的索引值结束print(players[2:]) # 没有结束索引就知道最后结束print(players[-3:]) # 倒数第三个 运行结果: 12345['charles', 'martina', 'michael']['charles', 'martina', 'michael']['charles', 'martina', 'michael', 'florence']['michael', 'florence', 'eli']['michael', 'florence', 'eli'] 遍历切片前面我们遍历列表的时候采用for语句来实现的，同理，切片同样可以采用for语句来实现。 代码示例: 1234players = ['charles', 'martina', 'michael', 'florence', 'eli']print("Here are the first three players on my team:")for player in players[:3]: print(player.title()) 运行结果: 1234Here are the first three players on my team:CharlesMartinaMichael 复制切片要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引([:])。 这让Python创建一个始于第一个元素，终止于最后一个元素的切片，即复制整个列表。复制的过程中可以进行赋值或者修改操作。例如新增一个元素。 代码示例: 12345678my_foods = ['pizza', 'falafel', 'carrot cake']friend_foods = my_foods[:]my_foods.append('cannoli')friend_foods.append('ice cream')print("My favorite foods are:")print(my_foods)print("\nMy friend's favorite foods are:")print(friend_foods) 代码结果: 12345My favorite foods are:['pizza', 'falafel', 'carrot cake', 'cannoli']My friend's favorite foods are:['pizza', 'falafel', 'carrot cake', 'ice cream'] 元组定义元组列表是可以修改的，主要适合存储程序在运行期间可能会变化的数据。如果需要创建不可修改的值就需要用元组，所以元组可以理解为:不可被修改的列表。但是元组采用的是方括号来标识。和列表同理，均可采用索引来访问元素。 代码示例: 123change_list = ('one','two','three','four') #定义一个元组 print(change_list[0]) #取元组索引为0 的值change_list[1] = 'hello' #修改元组中索引为1的值 会被报错，因为元组不可以被修改。 遍历元组遍历元组和遍历列表一样，采用for 来实现。 代码如下: 123change_list = (1,2,3,4)for number in change_list: print(number) 运行结果: 12341234 修改元组变量修改元组的变量不等于修改元组的元素，也就是给存储元组的变量赋值。 代码示例: 1234567change_list = (1,2,3,4)for number in change_list: print(number) change_list = (11,22,33,444)for number in change_list: print(number) 运行结果: 123456781234112233444]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础学习02天]]></title>
    <url>%2Fposts%2F3226%2F</url>
    <content type="text"><![CDATA[主要内容： 遍历列表，创建列表，range()函数使用； 统计列表数值，列表解析； 通过循环的方式遍历列表通常情况下，我们需要对列表的所有元素进行操作，这个时候就需要遍历整个列表。循环采用for。 语法: 12for change_name in list_name: print(change_name) 代码示例: 123magicians = ['alice', 'david', 'carolina']for magician in magicians: print(magician) 运行结果: 123alicedavidcarolina 循环的含义其实是将列表的值逐一取出，然后进行其他操作。例如拼接、赋值、运算等。 代码示例: 123magicians = ['alice', 'david', 'carolina']for magician in magicians: print(magician.upper() + ", that was a great trick!") 运行结果: 123ALICE, that was a great trick!DAVID, that was a great trick!CAROLINA, that was a great trick! 注意事项: python中语法需要注意的主要是忘记缩进和不必要的缩进; 列表后面的:不能遗漏; 对于位于for语句后面且属于循环组成部分的代码行，一定要缩进。 例如: 123magicians = ['alice', 'david', 'carolina']for magiciand in magicians:print(magiciand) 错误提示: 1234 File "for.py", line 3 print(magiciand) ^IndentationError: expected an indented block 创建数值列表range()函数认识range()函数产生指定范围的随机值。 代码示例: 12for value in range(1,7): print(value) 运行结果: 1234567➜ day2 python range.py123456 需要注意的是这是函数的使用，可以理解为[1,7); range()函数创建数字列表要创建数字列表，可使用函数list()将range()的结果直接转换为列表。如果将range()作为list()的参数，输出将为一个数字列表。同时还可以指定步长。 代码示例: 1234range_num = list(range(1,4))print(range_num)range_num_two = list(range(1,20,2))#指定步长print(range_num_two) 运行结果: 12[1, 2, 3][1, 3, 5, 7, 9, 11, 13, 15, 17, 19] 统计数字列表的值min() :找出列表的最小值;max() :找出列表的最大值;sum() :求和; 代码示例: 1234list = [1,2,3,4,5,6,7]print(min(list))print(max(list))print(sum(list)) 运行结果: 1231728 列表解析代码示例: 12squares = [value**2 for value in range(1,11)]print(squares) 要使用这种语法，首先指定一个描述性的列表名，如squares;然后，指定一个左方括号， 并定义一个表达式，用于生成你要存储到列表中的值。在这个示例中，表达式为value**2，它计 算平方值。接下来，编写一个for循环，用于给表达式提供值，再加上右方括号。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础学习01天]]></title>
    <url>%2Fposts%2F7874%2F</url>
    <content type="text"><![CDATA[主要内容： 列表概念，访问列表元素，修改列表元素; 删除列表元素，添加列表元素，组织列表; 列表概念列表由一系列按特定顺序排列的元素组成。可以创建包含字母表中所有字母、数字0~9或 所有家庭成员姓名的列表;也可以将任何东西加入列表中，其中的元素之间可以没有任何关系。鉴于列表通常包含多个元素，给列表指定一个表示复数的名称(如letters、digits或names)是 个不错的主意。 语法用方括号([])来表示列表，并用逗号来分隔其中的元素。 12bicycles = ['demo', 'chen', 'sen', 'lin']print(bicycles) 访问列表元素访问列表中的元素是通过索引获取的，而索引是从0开始的。 12345bicycles = ['demo', 'chen', 'sen', 'lin']print(bicycles)print("取第0个索引:" + bicycles[0])print("取第1个索引:" + bicycles[1])print("取第最后一个索引的值:" + bicycles[-1]) 运行结果： 12345➜day1 python dsc.py['demo', 'chen', 'sen', 'lin']取第0个索引:demo取第1个索引:chen取第-1个索引:lin 结合第0天的知识，我们现在对列表元素进行拼接的操作。 123bicycles = ['demo', 'chen', 'sen', 'lin']res = "My name is " + bicycles[0] + "!";print(res) 运行结果： 1My name is demo! 修改列表元素修改元素的值可以理解为通过索引获取需要修改的值，然后重新赋值。 代码示例: 1234bicycles = ['demo', 'chen', 'sen', 'lin']print(bicycles)bicycles[1] = 'Name';print(bicycles) 可以理解为: 123456bicycles = ['demo', 'chen', 'sen', 'lin']print(bicycles)change_res = bicycles[1];change_res = 'Name';bicycles[1] = change_res;print(bicycles) 运行结果: 12['demo', 'chen', 'sen', 'lin']['demo', 'Name', 'sen', 'lin'] 添加列表元素添加元素主要有两种方式：列表末尾添加元素，列表中插入元素(包含开头)。其中不能影响其他的元素。 代码示例: 1234bicycles = ['demo', 'chen', 'sen', 'lin']print(bicycles)bicycles.append('good')print(bicycles) 运行结果： 12['demo', 'chen', 'sen', 'lin']['demo', 'chen', 'sen', 'lin', 'good'] 甚至可以创建一个没有任何的元素空的列表，然后不断的追加元素。或者可以从开头或者中间插入元素。 代码示例: 12345null_list = []null_list.append('hello')null_list.append('senlin')null_list.append('chen')print(null_list) 运行结果: 1['hello', 'senlin', 'chen'] insert()可以在任意位置添加元素。 代码示例: 123in_list = ['hello', 'senlin', 'chen']in_list.insert(1, 'name')print(in_list) 运行结果: 1['hello', 'name', 'senlin', 'chen'] 删除列表元素删除元素的方法有:del删除、pop()弹出删除、根据值删除。 代码示例: 12345678list = ['on','list','time','man','like','goods']del list[0]print("删除第0个元素的值",list)print("弹出删除第最后一个元素的值",list.pop())print("弹出删除第一个元素的值",list.pop(1))print(list)print("根据值删除",list.remove('man'))print(list) 运行结果: 123456删除第0个元素的值 ['list', 'time', 'man', 'like', 'goods']弹出删除第最后一个元素的值 goods弹出删除第一个元素的值 time['list', 'man', 'like']根据值删除 None['list', 'man'] 组织列表组织列表中主要是针对列表进行排序等操作。排序分为临时排序(sorted())和永久排序(sort())。reverse()不是指按与字母顺序相反的顺序排列列表元素，而只是反转列表元素的排 列顺序:reverse()永久性地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，为此只需对列表再次调用reverse()即可。 代码示例: 123456789cars = ['bmw', 'audi', 'toyota', 'subaru']cars.sort()print(cars) #根据字母永久排序cars = ['bmw', 'audi', 'toyota', 'subaru']cars.sort(reverse=True)print(cars) #根据字母相反方向永久排序cars = ['bmw', 'audi', 'toyota', 'subaru']cars.reverse()print(cars) #倒着打印列表 运行结果: 1234['audi', 'bmw', 'subaru', 'toyota']['audi', 'bmw', 'subaru', 'toyota']['toyota', 'subaru', 'bmwmw', 'audi']['subaru', 'toyota', 'audi', 'bmw'] 获取元素长度代码示例: 123cars = ['bmw', 'audi', 'toyota', 'subaru']res = len(cars)print(res) 运行结果为：4 至此，第三章的列表已经学习完毕，本章的函数不是特别多。主要的知识点有概念，获取值，修改和排序等操作。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础学习00天]]></title>
    <url>%2Fposts%2F39399%2F</url>
    <content type="text"><![CDATA[主要内容： Python安装运行，变量； 数据类型：字符串，数字，空白，注释； 安装和准备主要查询官网文档即可解决。官网地址：https://www.python.org Hello World终端运行 命令行运行新建以.py结尾的文件，例如hello.py;打开该文件，输入：print(&quot;Hello World&quot;);,最后运行：python hello.py ; 数据类型变量基本使用变量就是保存一个值的信息，将其存储起来，随着程序后面的不断赋值（要求存储一个新的值），该变量的值也会随着改变。如下图所示，change变量就是被重新赋值了。 运行结果如下： 123➜day0 python hello.pyHello SenLin Chen!Hello Python SenLin! 语法和规则语法：变量名=赋值的值，例如change是变量名，Hello SenLin Chen!是赋值的值。这样变量change的值就是:Hello SenLin Chen!; 规则： 变量名只能包含字母、下划线和数字。数字不能开头。不能包含空格。例如:12_name;合格写法：user_name； 不能用python的关键字和函数名作为变量名，因为已经被用了，这么想就没事了。 变量名应该见名知意，尽可能简短。 字符串含义用引号括起来就是字符串。其中有单引号和双引号。例如：&#39;string&#39;,&quot;user_name&quot;等。 修改字符串大小写常用方法: title():将字符串的首字母设置为大写; upper():将字符串全部设置为大写; lower():将字符串全部设置为小写; 代码示例: 1234change = 'hello,my name is demo chen!'print(change.title())print(change.upper())print(change.lower()) 运行结果: 1234➜ day0 python hello.pyHello ,My Name Is Demo Chen!HELLO ,MY NAME IS DEMO CHEN!hello ,my name is demo chen! 拼接字符串使用场景:多个字符串合并为一个字符串形式。 使用方法:采用+的形式来拼接。 代码示例: 123user = 'hello'name = 'senlin'user_name = user + '_' + name 运行结果: 12➜day0 python user_name.pyhello_senlinenlin 添加空白制表符:\t;换行:\n ;可以组合使用。 删除空白&#39;demo &#39;不等于‘demo’;所以需要去除空白。 相关函数: rstrip():去除末尾的空白;lstrip():去除开头的空白;strip():去除开头和末尾的空白; 数字数字主要有整数和浮点数。主要的运算有:加(+)、减(-)、乘(*)、除(/)、乘方(**)等 代码示例: str():将非字符串表示为字符串。 注释#为Python注释的语法。 代码示例:]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[购买付费软件的一点感想]]></title>
    <url>%2Fposts%2F50238%2F</url>
    <content type="text"><![CDATA[使用付费还免费软件？ 是否应该付费？ 如何选择付费软件？ 付费还是免费？以前我使用Windows的时候，如果遇到付费的软件我都会选择注册机、注册码、破解工具等方式来解决，同时某盘还存了很多的破解的软件或者工具。现在我会逐步选择付费的软件，同时选择同类产品比较好的软件。因为我觉得付费购买是对人家的一种尊重和支持。同理，我是一个开发者，我希望我的作品别人也能够支持，支持别人其实自己也会得到支持。 如何付费？一般会根据自己的需求来判断自己是否需要这个软件的功能，是否能够解决我自己的问题？是否能够满足的我的需要？然后对比同类产品中付费和免费的相关的产品，如果免费的就足够就不需要考虑付费了。例如卸载软件AppCleaner，还有比它更加优秀的产品，但是我选择这个就可以了。同理，如果付费中我能够接受的价格能够满足就可以了，没有必要去选择最贵的活着最好的，主要是最适合自己的。例如剪切板工具有很多，我选择了iPaste，专注于剪切板功能。 选择付费是一种需要，也是一种支持，更是一种态度。 付费软件列表iPhone 软件名 价格(元) Price Tag 30 V2er 8 白描 1+6 熊猫吃短信 1 Picsew 1 凤凰新闻 Pro 1 Holo 0.00 小历 1 落格输入法 3 Piiic 1 iPaste 58.00 TextGrabber 30.00 X.cat Pro 40 Cosmos 0.00 Shu 12.00 鲨鱼记账Pro 1 Mac 软件名 价格(元) Clearview 78 MWeb 98 Yummy FTP Pro 198.00 iPaste 58 Xnip 12/年 Disk Drill 189.00 Total Video Converter 0.00 Folx pro 5 59.00 iStat Menus 6 14.00 暂时就想起来了这么点。。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《把时间当作朋友》阅读笔记]]></title>
    <url>%2Fposts%2F60177%2F</url>
    <content type="text"><![CDATA[该篇笔记是我学习李笑来老师的《把时间当作朋友-升级你的操作系统》的精华笔记。同时本书的内容也是我一直在践行的方法论，每个人都有困境，但不是每个人都会思考。如何思考？如何应用？ 第0章 困境缘起一般我们经常说的是就是“没有时间”。真的没有时间吗？ 慌乱于是我们开始着急，开始慌乱。 解决一个不争的事实：时间是不可被管理的。于是，我们开始反思自己，一切的问题都在自己身上。这一切都需要积累，只有积累到达足够的境界，时间就是我们的朋友，否则就是敌人。人是由概念和方法论组成的。一切靠学识决定，与其花时间管理时间，不如花时间提高自我解决问题的效率。 第1章 醒悟大脑我们竟然可以用自己的大脑控制自己的大脑。你的大脑并不是你，你的大脑是（属于）“你的”大脑，运用心智获得解放，不再让自己“跟着感觉走”，成为大脑的奴隶，而是翻身做大脑的主人。 心智一个人的心智就是器过往获得的一切知识以及经验的总和。其中包括基于这些知识和经验造就的思考方式、思考模式。心智，上不封顶下无保底，一旦打开，就可能因为学习而像病毒一样疯狂发展，与此同时，学习能力相应大幅度增长。 第2章 现实速成绝无可能期望速成有两个主要原因：第一个是希望自己的欲望马上得到满足；第二个是不懂“有些阶级是无法跨越的”。 交换才是硬道理“我要”的欲望可以用“我有”的东西来满足。如果行李是必须的，那么背动行李的唯一办法不是减负，而是让自己变强。 完美用不存在人人都希翼完美，只可惜，完美并不存在。越是能力差的人，越有那种非常不现实又极其脆弱的完美主义倾向。生活本来就不完美，谁的生活不是磕磕绊绊？谁又在死去的时候没有一丝遗憾？现实如此只能接受。 未知永远存在未知因素给人们带来的心理压力远远超出一般人的想象。首先我们要承认自己不可能全知全晓。其次，对于未知我们要分为两种，一种是永远不能解决的，一种是可预见的未来可以解决。当遇到解决不了的问题时候，我们可以先记下来，然后继续前行。 现状无法马上摆脱人们往往会低估环境的巨大力量。尽管天分很重要，但一个人的能力主要靠积累获得。心怀梦想的时间越长，它沉没的成本就越高。接受现状最优的策略是有什么做什么，有什么用什么，做什么都做好，用什么都用好。 与时间做朋友与时间做朋友方法很简单：用正确的方法做正确的事。几乎一切愚蠢的行为都来自于否定现实、逃避现实。只有接受现实，才能脚踏实地，避免心浮气躁，好高骛远。时间是现实的人的朋友，是不现实的人的敌人。时间不是故意这么做的，只不过事实就是如此。 第3章 管理估算时间错误估算任务所需时间是最常见，也是最致命的错误。要想提高估算时间的能力，就要从现在开始养成习惯：做任何事情之前先判断其熟悉程度（陌生程度），再据此判断估算完成任务所需要的时间。 及时行动拖延的主要原因是，首先很多人做事拖延就是“不求有功，但求无过”心态在作祟。只要做事，就一定会出问题。这是现实。其次就是过分在乎外界的评价。如果我们明白了这是现实，就要把这种认识纳入自己的心智，就不会对“最后期限”产生幻觉。所以唯一的策略就是：现在就开始。 直面困难就算没有低估完成任务所需要的时间，就算已经迅速开始执行任务，很多人还是没办法及时完成任务。这类效率低下的原因：回避困难。所有真正踏实做事的人都知道，任何任务的绝大部分都是枯燥而无趣的，所谓有创意的部分，可能连1%都不到。 关注步骤任何事情有三个方面：内容、原因、方法；任何任务有三个属性：何事、何因、何法；在做任何事情之前，通过关注“方法”去反复拆分任务，最终确认每个子任务都是可以完成的，这是一个人不可或缺的功课。这样的习惯会让一个人变得现实、踏实。 并行串行提高效率指的是：原本只能串行的完成的两个任务现在可以并行完成。一些早期的计算机是单任务操作系统，为了提高效率现在有多任务操作系统。很直接的体现就是：DOS是没有办法理解Unix的。让自己拥有“多任务操作系统”方法：可以将大任务分成足够多又不太多的小任务；划分自己的时间。 感知时间可以尝试通过“事件日志”纪录时间。除了自己亲身经历事件一概不记，尽量不记感受，不记感想，只记录事件本身。柳比歇夫的日志是：事件−时间日志。李敖的日志是只记录事件名称，是一种基于结果的纪录。两者差别在于：基于过程的纪录要比基于结果的纪录更为详细。基于过程的纪录有一个更大的好处，结果不好的时候可以更容易找到原由。管理时间基本不可能，那么解决办法是想尽一切办法真正了解自己，真正了解时间，精确感知时间，而后再想尽一切办法使自己以及自己行为和时间合拍，也就是“与时间做朋友”。 列表列表从来都是最有效的组织工具之一。最方便的列表工具是纸和笔。列表也没有必要工整，只要我们自己能看懂就够了。列表一定要随手可及。最重要的任务只有一个。判断一件事情是否真的重要，标准只有一个：是否对目标（无论是长期还是短期）的实现有益。制作专门的下一阶段任务列表。如果有什么新鲜主意不要放弃，只需要启用另一个列表（下一阶段的任务列表），把他们记录下来，然后马上回到当前的任务列表，专注于现在应该完成的任务上。给每个任务制定一个核对列表。列表一旦开始运作，就一定要执行到底。 流程要想加快执行重复性任务的速度，只需在遇到重复性任务时先将其做完一次，然后马上总结、整理，搞清流程，再进一步实践把它变成“闭着眼睛也能做好”的事。这是提高效率、减少失误的根本手段。 预演做任何事情之前，尝试把将要做的事情整个过程在脑子里预演一遍甚至数遍。只有经过大量的预演或者练习，才能够在实际执行任务的过程中有出色的表现。 验收很多人做事半途而废、不了了之的根本原因在于从未想过要给自己执行 任务时的表现设计一个验收机制。最基本的验收机制是针对最终结果的，部 分有经验的人因为在做事之前总是更关注步骤，并会按照需求将任务拆分成 若干子任务，所以，他们甚至会为每一个步骤设计相应的验收机制。 从更高的层面上说，设计验收机制也是任何一个领导者必须拥有的基本能力。哪怕你领导的只是一个很小的团队，你也必然要向团队成员指派各种各样的任务。在这种情况下，如果你没有设计验收机制，最终的结果肯定会让你非常失望，因为缺少验收机制会使团队成员对自己的工作质量毫不介意， 长此以往，团队的执行力将等于零，作为困队领导者的你也必须承担失败的责任。 第4章 学习学习是投资回报率最高的行为每掌握一项新的技能，就感觉自己像重生了一样。学习最关键的一点：任何知识的获取，都是不可逆的。学习的重要起点是：起码学会一种技能。总之，千万不要拒绝学习。 基本途径获取更多知识几乎是我们开拓自身心智的唯一手段。所有人过去知识最基础的手段就是“体验”。比体验更高级的获取知识的手段是“试错”。比较聪明且重要得多的获取知识的手段是“观察”。但是“体验”、“试错”、“观察”都有局限。原因：首先大量的知识无法通过个人亲身“体验”获得。其次有些知识很难通过“试错”获得。所以对此三者进行补充，那就是“阅读”。阅读是人们获取知识更加重要的手段。阅读突破了个人“体验”或“试错”的局限——“体验”和“试错”都只能通过自己，然而通过阅读可以获得别人的体验和试错结果。 主要手段准确的说：正确的思考，才是获得真正意义上的知识的主要手段。思考、求知的过程，某种意义上就是探求因果关系的过程。开启心智、正确思考更值得我们投入时间和精力。 经验局限学习过程最大的障碍就是经验主义。个体经验的局限案例：强光喷嚏反射。群体经验局限在于人类寿命有限。不仅存在无法通过个体或者群体经验获得的知识，还存在与现有经验相悖的知识。 自学能力自学能力的基础就是阅读理解能力。检索能力建立在相当熟练的阅读理解能力基础之上。写作能力在自学能力中占据重要位置。实践能力是自学能力最终转化为真正价值的根本。要永远保持开放的心态。 在频繁失望甚至绝望的情况下居然坚持了那么久，最后我们会发现，原来我们是这么地有毅力啊！ 第5章 思考相关命题有70%以上的人分不清原命题和逆命题之间的区别。每天有无数人因为分不清原命题和逆命题而被他左右。混淆原命题和逆命题，抹杀两者之间的差别，是广告设计者最常用，最舍不得放弃的手段。 举证责任针对某一论点，对立双方的举证难度并非对称的。首先，举证难度受证人能力的影响，因为每个人的学识和专业不同。其次，举证难度受当时所在社会的整体知识水平的影响。最后，举证难度还受需要证明的结论与当时普遍接受的知识相符程度的影响。 对立论证人们可能基于一模一样的原因作出截然相反的决定。也就是用相同的论证证明截然相反的论点。实际上所谓的情商，从根源上朴素地看，还是思考力的问题。 辨析感悟我们都需要清楚道理和感悟的区别。成功者其实没有必要、没有义务，也往往没有足够的时间去阐述所有的细节。与其关注成功者不妨反其道而行之：努力从失败者身上汲取经验。只有经过自己的仔细分辨，真正的成功者的宝贵经验才是无价的。需要额外注意的是，一方面多花心思分辨，另一方面多花时间真正了解自己，以便能够避开“一概而论，生搬硬套”可能带来的灾难。 克服恐惧道理都明白，可是做不到，这是无数人生活中无数人在生命中无数次遭遇的尴尬。人人都有弱点，因为人人都会有恐惧。不要以为我们拥有无比的勇气，不要以为自己没有恐惧，总有那么一刻，我们的勇气无法抵御我们的恐惧。所以，我们有什么理由不能理解别人的恐惧呢？ 辅助工具语言是一种便宜（甚至是免费）而又有效的辅助工具。当我们试图批判一个错误的立场的时候，即使是在完全正确地批判的情况下，也总会有这样的抵抗，例如：难道就没有一点可取之处吗？ 勤于思考独立思考，只不过是从别人那里知道一个结论的时候，自己动脑重新推演一遍，看看结论的过程有没有漏洞和不合理的地方衡量一下到底有没有道理的过程。权威不是用来迷信的，权威在更多的时候本应该是我们认识世界的辅助工具。 思维陷阱概念不清。学习任何东西最重要就是搞清它们所有的基础概念。永远都是那些能把概念理解透彻、区分清楚的人才能清楚地思考世界，进而改变整个世界。拒绝接受不确定性。拒绝接受不确定性的一个根源在于害怕复杂、奢望简单。 因果关系因果关系往往分析往往不像看上去那么简单，人们往往因为因果关系分析错误而得出错误的结论且不自知，进而莫名其妙做出错误决定，走上错误的道路。 基础。外因会影响内因，内因同样会影响外因。它们相互影响，互为因果。要做一个用心的人，要用心做事，因为这个世界其实有“心”。分析因果关系是我们在决定是否接受某个观点之前必做的功课。所谓的思维缜密，其实并非常人想象得那么高不可攀，事实上可能恰恰相反—— 做到并不难。很多人做不到的原因无非两个：习惯性拒绝思考和不懂得应该如何思考。而前者往往是由后者长期作用的。 第6章 交流学会倾听正如没有人会认为自己不会说一样，几乎没有人会认为自己不会倾听。可事实上，大多数人不懂的应该如何有效的倾听。人类讲话的速度往往低于思考的速度，所以我们在倾听的过程中常常容易走神。如此这般下去终究会真正错过重要的信息。必须想办法获得一种或者一些用于鉴定已知信息有效性的知识。 那么如何倾听？ 为了做到真正有效的倾听，最需要克制的就是“过早质疑”。 在倾听过程中，我们可要利用多余的脑力处理两个方向的信息：“回顾”与“预期”。 一旦决定倾听，就要主要主动帮助说者进入“倾诉”状态。 说与不说有一种极为常见却又几乎总是被忽略的现象：明明是同样的话，自己说出来就不像那么回事。通过努力和积累成为能说更多话的人。有时候，我们知道自己说的是对的，但是没有人听得进去，绝大多数人面临这样的情况多少有些失落，甚至愤怒，可事实上，这往往说明一个问题 ：还没有赢得足够的重视。 交流守则 有意义讨论的前提是双方不仅要“相互竞争”，更要“相互合作”。 真理是独立存在的，他从来不会依附于任何个人或者集体。 真理不变，也不会因任何人而变；不停变化的只是人们对真理的理解或者解释。 正确复述沟通在很多时候并不像看起来那么容易。在这个过程中我们常常会因为某个参与者而导致“有效沟通根本不可能达成”。如果甲乙两个人需要沟通，那么他们沟通的过程是：甲将他想法用语言表达出来，已用自己的方式去理解甲的语言，然后反过来再次进行。此过程可能重复多次。但是两者的编码、解码机制常常不相同。所以为了保证沟通顺利，往往需要添加一个验证机制，或者说反馈机制。 这就需要我们在生活或者工作中给予别人一个反馈或者回复，让对方对此事有一定的知情权这样才能保证事情的沟通顺畅，效率更高。 勤与反思在讨论问题的时候，我们常常会被对方“固执已见”挫败，但对方眼里，我们可能也是“固执已见”的，只不过是程度不同而已。 所以，我们更需要如何做呢？ 深刻了解经验的局限。摆脱经验主义的第一个技巧：了解经验的局限性； 时时刻刻保持警惕。经验需要归纳，更需要经过演绎来论证； 使用记录，使自己能够记住更多经验。做记录是一个很好的习惯； 通过观察和阅读汲取他人的经验。观察和阅读是扩充有限的自我经验的最好的手段； 试用类比来跨越未知与已知的障碍。类比思考几乎是跨越已知与未知之间鸿沟的唯一手段； 耐心等待以拥有不能快速获得的经验。遇到不理解的问题或者不确定的想法先记录下来，保持耐心。 第7章 应用兴趣首先，有些人并不是对自己正在做的事情没有兴趣，而是没有能力把目前正在做的事情做好。其次，人们常常说他们真正感兴趣的事情是其他事情。综上，我觉得兴趣不是那么重要，至少没有我们想象的那么重要。因为往往不是有兴趣才能做好，而是做好了才有兴趣。 方法方法固然重要，但是比起“用功”来说，方法几乎可以忽略不计。所有学习上的成功只依靠两件事：策略和坚持。而坚持本身就是最重要的策略。坚持就是重复；而重复就是，说到底就是时间投入，准确地说，是大量时间的投入。与其不停地寻找“更好的方法”，还不如马上行动。 痛苦对痛苦的深刻感受，会扭曲或者抹杀人们感知其他事物的能力。痛苦就是这样，一旦我们学会在痛苦的时候运用心智把自己的注意力转移到其他地方去，痛苦就几近自动消失，而且在它被我重新注意之前绝不会回来。 比较在很多人眼里，所谓的成功，不过是比较的产物，归根结底就四个字：高人一等。但是，比较是相对的，相对是永远没有尽头的。很多时候比较是一个坑，大坑。再干脆点说，比较是陷阱。 生活无法彻底回避比较，但是无须比较就可以获得快乐和幸福也同样很多，只不过常常被人忽略。其实比成功更重要的是成长。如果成功是和别人比较，那么成长就是和自己比较。显然，成长比成功意义更大。 运气首先，运气是存在的；其次，运气是有好坏之分的。但是，相信运气是缺乏自制力的表现。当好运气发生在自己身上时，我们应该开心，当坏运气降临在我们身上时，我们呢应该平静接受。心态很重要。尽管对生活不应该盲目乐观，但一定不能失望悲观。 人脉基于某种原因，生活中广受欢迎的人总是少数。所有的人都喜欢并重视甚至偏爱一种交换：公平交换。资源更多的人更喜欢也更可能可能与另外一个资源数量或者质量对等的人进行交换。所以，承认知己能力有限，是保持心理健康的前提。 自卑每一个人都有一个愿望中的自己，同时还有一个感觉中的自己。最佳状态是：愿望中的自己=真实中的自己=感觉中的自己。但是很多时候是约等于并非等于，但是也有部分人处于不等于状态。 作为社会的一员，大多数人并没有意识到，有时候，整个社会向他灌输的关联可能是错的。 优秀的人更容易自卑。 停止嘲笑他人。 忘记自己的优点。 在自己语言中，把“优点”和“缺点”这两个词换成“特点”。 适当地放纵一下自己。 灵感素材固然重要，但是，如果提前确定一个方向或者目标，就可能会积累很多原本想象不到的素材——惊喜连连。不要无谓的相信什么“突然闪现的灵感”的存在。灵感这东西就算存在，也不会平白无故出现的，而是肯定有来历的。所以，以此类推，所有的成功，在本质上都是一样的。先花上相当的时间和精力去锁定一个方向和目标。确定它现实可行之后，运用心智的力量，在这个方向上投入更多的时间，比更多再多一点的时间，“必然”就会产生。 鼓励永远鼓励身边的人，哪怕多少有些盲目。当我们不停地鼓励所有人的时候，最大的受益者其实是我们自己，因力最终我们会发现，自己开始进入一种他人无法想象的伏态，成为一个不需要他人鼓励的人。这一点很重要。因为很多人之所以做事裹足不前，浪费时间 甚至生命，原因就在于他们是必须获得别人的鼓励才敢于行动的人。可是，我们却能成为另外一种人——我们可以不需要被别人鼓励——这是一种境界。 效率任何人都不可能100%地有效率，至少不可能总是100%地有效率。确定自己是什么样的人，熟悉自己的专注的重点，然后通过一定的练习，进而控制我们的大脑。当一个人经过一段时间的训练后，分割时间的方法对他来说就没有必要了。因为，他应该已经可以比较自如的专注在他应该做的、非常重要的事情上了——无论这件事情是有趣还是无趣。 节奏我们应该把自己的生活节奏调的慢一点。想办法提前预支自己需要掌握哪些技能，在确定它们是自己可以通过练习真正熟练掌握的技能，而后制定长期的计划，一步一点稳步执行。 物极必反 不要盲目的试图减少睡眠时间。 尽量不要减少与家人交流的时间。 最好不要放弃自己的社交时间。 自我证明长久的观察和思考，有益干锻炼自己心气平和的能力，反正别人 如何认为、如何评价、如何议论根本没办法影响一个人所处的状态。但是，一旦某个人开始为此心烦意乱、坐卧不安，甚至为此有一些无聊的举动，那么他就不仅是倒霉，而且是可怜了， 因为他已经被别人左右了。被别人左右，是一个人相当可悲的状态之一。 第8章 积累坚信积累现状会影响一个人的心态。如果有一个人心态受到了现状的影响，那么他的行为和决策都会随之发生变化。进而，行为和决策的结果形成新的现状，再次影响心态，形成恶性循环。 任何积累都需要时间，而且必然需要漫长的时间。也正是因为如此，大多数人才不肯积累，不愿积累，甚至不谢积累。相信积累的力量本质就是相信复利的力量。 越早醒悟越好，坚信积累的力量。 越早越好越早开始的事情没有几个，理财排在第一位。理财困难与矛盾来自这样一个窘境：很难很早开心，等开始的时候已经太晚。 为什么今天的人需要重视理财？第一：人们的平均寿命变得长了；第二：人们可获得收入的工作时间也随之变成了。 理财最难得两个地方是对自我的把控和对风险的把控。但是这两个技能可以通过习得而习得，最重要的是必须通过反复实践。 转移注意力是抵御诱惑的一种常用的有效手段。理财的风险意识必须通过自己的实践、失败、教训、总结才能获得的东西。 所以，理财这件事越早越好，开始学会理财，可能是改善自制力、自控力的方法。 如何开始 从今天开始存钱。 该花就花，有时候就要活在当下。（有时候） 爱面子其实是绝大多数人存不下钱的根本原因。 给自己培养一个不那么费钱的兴趣爱好。 开源节流。开源是正途，努力提高未来的营收能力才是当务之急，花时间提高自己的大脑。 给自己一个机会，在5年之后体会一下突然可以动用一笔闲钱的机会。 躺着赚钱收入分为两种：主动收入和被动收入。主动收入：就是必须做点什才能获取的收入。被动则相反。例如利息。很多人不仅没有“睡后收入”，还有“睡后支出”。分期消费的负担其实很重。创作和课程都是是一个睡后收入的不错选择。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>阅读</tag>
        <tag>笔记</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《新生-七年就是一辈子》阅读笔记]]></title>
    <url>%2Fposts%2F15148%2F</url>
    <content type="text"><![CDATA[谁不想进步呢？什么进步不需要方法论呢？没有救世主，就只能自谋出路。哪怕不是路人甲，其实也一样要不断进步，不是吗？本文主要是学习《新生-七年就是一辈子》的阅读笔记。 人生最重要的概念：复利时代我们恰恰活在一个知识变现很容易、且越来越容易、且变现金额越来越大的时代。 践行最根本的学习与创作：践行。想到了，就去做，做到了，才算践行，做不到，没用。 行动想到了，就按照正确的想法做了 ，不管别人是否理解，这就是践行。想到了，学到了，就当真了；当真了，就当真做了，且真的做到了，这才是践行。 赚钱赚钱慢是一种罪，原罪。赚钱一定要快，要快到超越“第二宇宙速度”，不然你飞不出去。 商业计划你的商业计划就是你的赚钱计划。 衡量标准使得衡量商业计划的标准特别简单： 你可能赚到多少钱？你最快多久可能赚到那么多钱？ 主动选择 重生的关键选择衡量一个人是否真正活着的根本方法，就是看他是否有意愿、有能力做出主动的选择。 放纵自己停止嘲弄他人，忘记自己的优点，适当地放纵一下自己。 对比拿着现状与他人相互比较，必然总有这样那样的不足 —— 而比较带来的幸福感，通常也是虚妄的。即便是要比较，那被比较的对象也应该是“自己的现状”和“自己的未来”；而不是“自己的现状”与“别人的现状” 自信衡量一个人是否真正自信，就看他是否能真心为他人的成功而毫无芥蒂地感到高兴。 升级操作系统每个人的大脑里其实都有一个属于自己的操作系统，真的跟计算机一样！每个人都有一套属于自己的输入输出体系（IO 系统），有着一套属于自己的运行处理机制，这世上没有完美的操作系统，我们必须持续地主动升级我们自己。 方法论我们从计算机上可以学到的，其实是极少数极少数聪明人的思维方式和方法论。 类比思维在面对新事物的时候，我总是告诫自己，暂时先克制寻找类比的冲动，因为不恰当的类比还不如没有类比，甚至，不恰当的类比干脆相当于有毒，会麻醉我们的大脑，阻止我们有效地思考。好的、精妙的类比超级炫酷，可还是要小心为妙，因为类比真的影响思维。 应用场景学会任何一个概念、方法论之后，都要问自己：这个道理还能用在什么地方？ 概念概念是一切知识的基石，概念是一切知识架构的基石。 所谓的“独立思考” —— 少有人真正拥有的高级能力 —— 对其最朴素的描述无非是：能够独立地、正确地使用正确的概念。 非议、争论、鄙视链善恶其实是次要的所谓“人人心里有杆秤”——那秤称的其实是强弱。 让自己更强大面对非议的时候，真正要解决的问题不是去辩解，而是想办法让自己变得更强。 起点在起点上，每个人都一样，其实是没多少选择的，其实大多只能是被动状态麽，这很正常。 产品做出真正好的东西，销售就好像是不存在了一样，放在那里就行。 做好产品把东西做到真好，直至最好，其实是最省心、最省时的方法论。 说服别人说服他人有两个重要的终极诀窍：第一个，让对方自己得出结论，而不是把结论塞给对方；第二个，实际上是第一个的升级版：自己成为榜样，对方若是认同，自然就会追随。 解决问题的方法论有些问题是永远解决不了的解决不了的问题就（暂时）别去解决了罢，面对永存问题，尽力就好。 有些问题是不用解决的有些问题，看起来很重要，实际上却没那么重要（不是不重要），把时间花在解决它们身上，实际上是浪费的，效率低下的。 更多情况下，“细节很重要”是用来吓唬那些没做成过事儿甚至压根就没做过事儿的人的。主次不分，是绝大多数人的永存问题。我们不能这样。如果有问题非要解决不可，我们一定要分清楚那里面的主次，把最重要的先做好，这个做到了之后，再去关注细节，而这样的时候也确实有能力关注更细的细节，否则，本末倒置，一无所是。 有些问题可能会自动消失有一点问题就坐立不安的人，本质上只是天真。 有些问题是自己造成的基础很重要！这么朴素、简单、有效的建议，绝大多数人这一生都没听进去过 —— 然后，最令人啼笑皆非的是，一生都要为此付出巨大代价却又从不自知。 有些问题是其他人的问题为什么要坚持锻炼呢？答案是： 本金最重要。 有些问题是所有人的问题坏事发生在自己身上的时候，自己不吱声，希望有人替自己出头，却又完全不知道“替天行道”实际上是成本很高、风险很大的活动……说实话， 这从某个角度望过去，哪儿是天真啊？不仅是自私，还是深刻而隐秘的恶毒。 大多数问题需要特定的人解决所谓的“平和”只不过是认真思考的结果。 惊喜与创造惊喜的方法论你必须相信你自己会有好运的我真的相信惊喜是可以创造的，而且从一开始就笃信这事儿。乐观是一种需要时间、需要耐心才能生成的一种态度。 尽量不做可能倒霉的事情所谓“尽量不做可能倒霉的事情”，其实只不过是打磨自己的逻辑思考能力，使其完善，乃至于你不大可能去做未来可能产生恶果的事情。 保持开放开放就是可以创造好运和惊喜的，无论在哪个领域。 持续学习学习，从来都是创造惊喜、创造好运的最优路径。学习就是反复打磨概念与方法论，等着注定的惊喜注定地发生。 创造更多的连接只有节点多到一定程度，才可能有“意外的连接”出现。认识很多的人，其实是没用的，因为绝大多数人是没有操作系统的，或者即便有，也是过时的操作系统。认识他们没用，不仅没用，甚至是一种罪，因为你在耽误自己可能的效率。 要想办法认识很多真正拥有高效率的操作系统的人。长期以来，我发现外界的定义都是没用的，学历、身份、地位等各种标签，都是除了迷惑他人之外完全没用的东西。到最后，只有一种方式有用：交流。可能是坐下来喝茶，也可能是读对方的文字，更可能是长期观察。甄别出那些有属于自己的高效操作系统的人，甄别出那些愿意打磨自己的操作系统的人，遇到了，必须马上连接。 保留适当的随机在一些时候，在一定程度上，跨越因果思考与判断，在生活、工作、学习中添加一点随机性，就是创造惊喜的方法论。 多管齐下，齐头并进一定要想办法把自己打造成一个多任务操作系统。不要做一个低级的单任务操作系统。通过恰当的统筹，让自己多开几个进程，齐头并进地去做一些事情，永远是提高效率的基本手段。通过恰当的统筹，让自己多开几个进程，齐头并进地去做一些事情，永远是提高效率的基本手段。 而多管齐下，齐头并进，也是创造惊喜的好方法，理由很简单，效率高了，成果就多了，成果这东西，跟之前提到的“连接”啊、“节点”啊一样，越多越好，这些成果本身也是节点，它们之间也会产生连接，最终一样产生聚变，至于能够获得什么，我们还不知道，但我们知道一定会有所获得。 总结：逻辑很重要、概率学很重要、统筹学很重要 如何回避坏运气成功= 技能+运气所谓“运气”，是完全不可控的，它可能是好的，也可能是坏的，也可能是“0”，即，什么影响都没发生。我们不知道它什么时候发生，不知道它是好是坏，也不知道它好坏的程度到底如何；我们只知道最坏的情况下，坏运气可能导致“灭顶之灾”。 与之相对，技能却是可控的通过刻意练习，绝大多数技能都可以获得极大的提高。通过选择来回避坏运气。选择很重要。甚至可以不夸张地讲，人生就是选择。 在“技能-运气”的横轴上，尽量选择去做靠近左端的活动，就是那些更多依赖技能，更少依赖运气的活动。 调整焦点：有一个不可或缺的方法论 很多人输就输在，对于新兴事物，看不见、看不起、看不懂、来不及。把焦点放在大势自身上，而后开始思考，思考的结果常常是一样的：必须跨界 —— 自己手里正在做的事情，常常与那大势完全没有关系，也并不适合与那大势共存。 真正的大势，很少频繁出现，尤其对个体来说，能够感知的大势更少。 我们在自信这件事儿上，关注的焦点更多在于自己的未来 ，而不是，或者不仅仅是自己的过去或者现在。 不能容错的系统肯定是脆弱的容错机制任何一个在现实世界里运转的系统所面对的，必然是一个不完美的、不理想的、各种意外频繁发生的现实世界。我们最好给自己的操作系统设置一定的容错机制。 冗余设计没有冗余度设计的系统，通常不够健壮，不够可靠。冗余设计，就是为了能够让一个机器（或者系统）在非正常情况下也能运转，要把一些关键的组件安放一个以上…… 万一其中一个坏了，机器依然能够正常运转，甚至可以在机器的运转过程中修复或者替换那个坏掉的组件。我们人类自身就是个“冗余度”很好的设计 ，我们有很多重要器官都是有一个以上的，比如肺、肾、手、足等等。所以，摘掉一个肾、断了一只手、少了一条腿、瞎了一只眼、掉了一只耳朵、少了几根手指或者脚趾…… 这些本质上来看都不大影响一个人继续生活。 一切更为健壮的都要耗费更多的成本容错机制的收获有了容错机制之后，最重要的收获是：学习范围广了，思考更为深入了。 为什么一定要自学自学能力是靠积累增强的自学很简单，其实就是不断习得、积累、研究、打磨、升级那些概念和方法论。 融会贯通融会贯通：只有概念多到一定程度的时候，它们之间才有机会产生“意外的连接”。 自学态度自学这事儿， 方法并不首要，首要的是态度。 不同选手“表现型”选手做事常常不是为了自己的进步 ，“进取型”选手做事是为了自己的进步。 为啥人丑就要多读书？所谓的聪明，虽然可能也受先天条件限制，但聪明确实是可积累、可锻炼的。 人们的生活状态发生变化时，基因也会发生变化。 多读书罢，让自己更聪明一点，也为了下一代。 如何真正消化一本书？阅读功利性大多数情况下，阅读并没有功利性。完整性阅读，是没办法有功利性的，因为其实完全没办法知道所读、所学的东西究竟什么时候才能真正发挥它的核能量。 不可替代别人是不可能帮你吃饭的。同样的道理，别人其实是完全没办法帮你读书的。 阅读思路先大致浏览，知道大致的内容和别人对他的评价。拿来一本书，就好像要打一场仗，打仗之前最好先考察一下地形吧？ 同样的道理，拿来一本书，不应该是抓起来就从第一个字开始读起，一直读到最后……应该先看看目录，再看看附录，仔细读读前言，也不妨在网上先扫扫书评，要先大致对这本书有个了解，然后再开始行动比较好。 消化在读的过程中，不断整理这些概念与方法论之间的关系，其实是“消化”的必要过程。一定要用起来。 总结&amp;预期在阅读的过程中，要不断向后总结，向前预期。这是最基本的理解技巧。教是最好的学习方法。 分享的技巧很简单 真诚，只分享自己确实觉得好的东西；也是真诚，绝对不能居高临下地装蛋；还是真诚，对方完全有可能不理解你。这个概念、这个方法论、这个道理、这个知识，还可以用在什么地方？与喜欢学习的人泡在一起。 选书的基本原则出版社锁定领域知名出版社。 作者靠谱的人写的东西靠谱。 版次版次越高越好。 印次印数越大越好。 印数第一版第一次的首印数。 “编”与“著”优选“著作”。 参考文献更多经典书。 其他要点 索引；尽量不读译作；花时间读书评，亚马逊、豆瓣等；看看牛人在读什么？ 什么是更好的知识？有价值的信息才可以算作知识。知识分为两种，无繁殖能力的和有繁殖能力的。科学方法论，就是一种有繁殖能力的知识，也是迄今为止我觉得最有繁殖能力的知识。有繁殖能力的知识： 可以积累，因为它有积累效应必须应用，因为它有指导意义值得传播，因为它可造福大众 活在未来，而不是当下活在未来超越绝大多数人的窍门其实很简单，就是想办法活在未来。 如何活在未来？笃信逻辑。用逻辑去判断明天会发生什么。 凡事均可以预演做事之前常常要在脑子里预演至少一次 。 顺序4、应该是 学习、工作、生活。不是 生活 、工作、学习。 即:按照未来的你所需要的标准去学习、去工作，将会构建一个完全不同的生活。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>阅读</tag>
        <tag>笔记</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之礼貌地回避问题]]></title>
    <url>%2Fposts%2F27069%2F</url>
    <content type="text"><![CDATA[转移话题不如转移角度，从大方面回答，直接反问原因。 礼貌地回避问题第一步 转移角度把话题重点转移到对方身上，把对方淡谈话主角自己当配角。回家长辈问婚事相关，反问阿姨请教一下阿姨你们家某某好像挺幸福地，阿姨说说呗。 第二步 提升层次隐私上升大问题，把隐私换成科普，解释机制。从大方面去解释问题背后地机制，而不直接回答具体细节；绕过个人工资细节去科普行业情况。 第三步 追问原因追问对方问这个问题地原因，让提问的人自觉无趣。例如：您为什么这么关心我的事，你是这方面有问题？？]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之在分答上提问]]></title>
    <url>%2Fposts%2F29454%2F</url>
    <content type="text"><![CDATA[分答不需要解释。 用提问赚钱奔小康。 精彩演讲用问题串联第一步 不要问大问题，要问小问题问题太大，太跳跃，答案对你来说没什么用处。例如：如何成为一个好的演讲者？答案：保持平常心。 没什么用 第二步 把问题反过来问一次案件发生后，警察问：有什么没有什么寻常事情发生？侦探问： 当前晚上有没有什么没发生？为什么现在的直播这么火？换一种问法：为什么过去直播没这么火？ 第三步 不要问成功，要问失败的理由失败的理由比成功的原因更有价值 3. 数据结构3.1 管理账户admin 和 unit 用于数据运维，admin 权限大于 unit; admin 和 unit 用于数据运维，admin 权限大于 unit，unit 用户只能看 unit 用户只能看到属于自己的数据，admin 用户可以看到系统 全局的数据。且只有管理员有账户 API 的权限。 3.2 业务账号user 普通用户，direct 导播用户，device 直播机账户。 user 普通用户，direct 导播用户，device 直播机账户。3.3 账号操作 管理员可以创建 unit 用户，user、direct 和 device 均由 unit 管理。 3.3 账号操作管理员可以创建 unit 用户，user、direct 和 device 均由 unit 管理。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之用提问求关注]]></title>
    <url>%2Fposts%2F13349%2F</url>
    <content type="text"><![CDATA[背景： 自己讲话没人听 听众来了，昏昏欲睡 听完没什么影响 精彩演讲用问题串联第一步 用提问吸引对方来听问句作为演讲标题。把所有的小问题总结从一个大问题。吸引注意力(点击率)。 第二步 抛问题扔答案，抓注意力不要太快公布正确答案，小问题引起好奇心。好奇心来自于对于自我经验的挑战。逐步抓住大家的好奇心。 第三步 用小问题引出冷知识，留下深刻影响有趣的比有用的问题比较好。 留下一个冷知识。例如为什么屁会臭？]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之用提问提逼格]]></title>
    <url>%2Fposts%2F19031%2F</url>
    <content type="text"><![CDATA[重要场景: 公司面试最后一句：你对我们公司有什么问题？ 提出有价值的问题顺应充分理解对方的话；从对方所说的话延伸；不要从自己的立场出发； 爱因斯坦问牛顿，如果一个人顺着光跑，跑到哪儿了？ 提升归纳，把一连串的小问题总结一个大问题。总结对方的问题，然后提出来问题，升华。 跳跃遵循对方逻辑。举一反三。把对方的思路跳出来到另一个他自己都没有想到的问题。跨领域，跨学科。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之跟父母打电话]]></title>
    <url>%2Fposts%2F33151%2F</url>
    <content type="text"><![CDATA[哄父母开心的三心技巧：安心 舒心 开心。 三心技巧第一心 细节让父母安心老老实实汇报生活现状。不要大而笼统的说一句：一切都好请放心。看什么电影和哪个朋友吃了什么……. 第二心 用问题使他们舒心别用工作，用他们的得心应手的生活来询问。 第三心 拿对比让他们开心父母年纪大了，不可避免被社会边缘化，要把自己的闪光点告诉父母，你变成别人眼中的”别人家的孩子”。舒缓他们的社交压力。 打电话就是沟通场景，把主动权交给对方。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之把内向变成优势]]></title>
    <url>%2Fposts%2F39869%2F</url>
    <content type="text"><![CDATA[不同性格的人找到让自己舒服和让别人舒服的说话之道。 如何把你得内向变成优势，内向能hold住全场。 内向说话的优势： 表达的缺陷不是缺陷，反而很可爱； 别人接受你是内向的人，别人会给你加分； 适应专注做事情，有工匠精神。 内向说话怎么做： 自嘲。化解紧张气氛，承认自己内向，别人的印象分会有很大的加分。 建立信任。先让别人新人，然后喜欢自己的话。 由小见大。把主题缩小，细致化。真情实感。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之激发别人的善念]]></title>
    <url>%2Fposts%2F26581%2F</url>
    <content type="text"><![CDATA[嘴甜一点，态度低一点，礼貌一点； 如何激发别人的善念，请人帮忙说话的诀窍。 三步回应法第一步 让别人感受到做和不做的差别 诉求要具体，让对方知道有画面感。 A：抱歉我母亲年纪大了，可以请你让个座吗？B：抱歉，我母亲年纪大了，如果这么远的路没人给她让座，她老人家只能坐在地上了。 第二步 努力让对方相信，他的善意不会被糟蹋 善意要扩大，让对方的付出更有意义。 A：抱歉我母亲年纪大，可以请你让个座吗？B：抱歉我母亲年纪大了，如果您愿意让座，我会非常感激，我保证您的好心不会白费，下次如果我遇到其他有需要的人，我一定也会向您一样伸出援手。 第三步 让对方知道自己有选择 让对方有选择。 A：抱歉我母亲年纪大，可以请你让个座吗，拜托拜托，求求你，发发好心把？B： 抱歉我母亲年纪大，可以请你让个座吗，当然这是您的座位，让不让由您来决定。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之鼓励一个不求上进的人]]></title>
    <url>%2Fposts%2F19824%2F</url>
    <content type="text"><![CDATA[如何鼓励一个不求上进的人？ 三步鼓励法第一步 降低他对结果的恐惧不努力是人最后的安全区，让他走出安全区，卸下防御；消除他对后果的恐惧。 第二步 用可能性代替目的性目标很单调大可能性无限，不要做比较，让他打起精神；最忌讳作比较。 第三步 营造愿景而不下达具体指令愿景是感召，而非具体承诺，激励的本质是对个体可能性的探索，而非鼓吹或胁迫人家完成的工具。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之说特别的话]]></title>
    <url>%2Fposts%2F65425%2F</url>
    <content type="text"><![CDATA[场景：婚礼致辞，领导讲话，主持人念广告 如何在大家都不想听的时候说话化腐朽为神奇的艺术 三步表达法第一步 不要装，要点破最尴尬的是假装自己不尴尬，点破就是换了位置，与观众站在一起，调用气氛。 第二步 该讲的还是要讲想清楚讲话的意义和责任，仪式性的场合致辞的意义大于其说话内容。最好说清楚自己的应该要讲的。 第三步 看清楚给谁听仪式性的场合说的话一般不是给观众听的，而是对主办方听的，替观众吐槽一下可以把场面热回来。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之应对反应慢]]></title>
    <url>%2Fposts%2F45767%2F</url>
    <content type="text"><![CDATA[辩论不是说给对方听的，是说给第三方听的，要争取第三方的认可。 慢半拍也能好好说话第一步 复述问题争取时间发现陷阱，用自己的语言复述，荒缪之处自然显示出来。 第二步 慢而不断用一以贯之的逻辑慢慢讲，不能偏离原有逻辑，逻辑线不断。 第三步 化繁为简将大问题归纳小问题，掌握最根本的问题。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之拒绝借钱]]></title>
    <url>%2Fposts%2F38639%2F</url>
    <content type="text"><![CDATA[如何拒绝别人借钱 不伤和气不伤钱的回绝之道 拒绝借钱三要点：第一点 少借不如不借借钱的多少与感情远近相关，自己内心的估算少于对方的，折中都不舒服。 不要回答：借多少？ 第二点 先问原因别问金额把战场放在对方那，把主动权抓在手里，购买行为借钱，请用关切的态度来确定对方缺钱的额原因。 第三点 根据对方的原因给出相似的不错理由可以暗示了最近一段时间都没闲钱。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之谈加薪]]></title>
    <url>%2Fposts%2F49874%2F</url>
    <content type="text"><![CDATA[请求派：不断强调自己过的多苦，通过强调自己的惨况，请求老板加薪； 老板对你的同情 威胁派：摆出自己不爽，长时间被亏待，我觉得你现在不给我加薪，我就离职。 风险太大 谈判的基础基于对方的人品，是不可取的！ 怎么谈加薪？第一步 确认加薪标准最重要的一步。不要一上去就说加薪。 问出老板加薪的客观标准。 可以问：在我们公司里，想我这一层员工，大概要达到什么样的标准才可以加薪？注意，不是在问还需要做什么才能加薪，而是要问在这个公司里面加薪的客观标准是什么？ 这样加薪是否合理的姿态，而不是老板个人决定。 第二步 讨论工作表现大大方方与老板讨论个人表现。假如自己没有达标，通过条件交换。例如在A项目业绩超标，B没有达标，那么可不可以通过A的业绩补偿B的呢？ 第三步 带领老板想想未来老板如果我们得到加薪，我们接下来就可以在项目中更加努力。 总之让老板觉得在公司中给你加薪是未来公司发展最值得的一件事。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之回应认真你就输了]]></title>
    <url>%2Fposts%2F25279%2F</url>
    <content type="text"><![CDATA[吵架。 认真你就输了，死活不讲道理。 三步回应法第一步 想清楚吵架目的争夺话语权，并提出自己解决方案。 第二步 同理反抽根据对方的逻辑得出对方不对的结论。“认真你就输了”。 答：“我们只是在讨论问题，你竟然在计较输赢？” 第三步 降维打架让对方觉得你们不是一个层次的人，你高于对方。 在吵架中取得话语权，并且将对方的重新新的谈判或者辩论，这才是现代谈判的王道！]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之聆听]]></title>
    <url>%2Fposts%2F55821%2F</url>
    <content type="text"><![CDATA[如何成为好的聆听者？ 主动聆听才能打开心门。 聆听不是好好听人家说话。 采用主动式聆听。 主动式聆听三部曲第一步 善用反馈 反馈方式:无声（点头，微笑）和有声（真的呀？….） 例子：郭靖和老顽童？禁忌：不要说我明白你的感受！不要表示理解对方。 第二步 事实重复归纳对方的重点，重复一遍，表达一遍，及时反馈。 第三步 寻找共鸣对方的话题你不合意，就尽量寻找共鸣的话题。 上级说：你喜欢喝啤酒吗？下级：你喝啤酒一般喜欢配什么吃的呢？下级：炸鸡（或者其他）。下级：我超爱吃炸鸡，你喜欢吃哪家店的？ 把啤酒引向了炸鸡（其他） 不要用刻意迎合对方来寻找共鸣。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之对上级说不]]></title>
    <url>%2Fposts%2F54874%2F</url>
    <content type="text"><![CDATA[千万不要对老板说没办法，要说就要说正在想办法； 老板提出来的要求，合理的叫训练，不合理的叫锻炼。 领导也是人，使人总有犯错的时候，做好了是上级的，做不好就是我的错。 对老板说不，不是不行是要讲智慧。 怎么对上级说不第一步 战略上高度肯定取得信任。 表态：表明我没有抵触情绪，理解他的出发点。 第二步 成本上精密核算 用事实和数据证明此事不可行。 最关键的一步。让上级知道这事情划不来，而你也是在尽力执行，不是在和他对着干。详实的论据是你的支撑 第三步 决策权完全上交用中立的态度让领导自己打消念头。 做出决策权完全上交的姿态。 不要让老板觉得他自己算的不好。 不动声色将你的成本核算给他看，绝对不能做。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之你行你上]]></title>
    <url>%2Fposts%2F7736%2F</url>
    <content type="text"><![CDATA[背景：别人在推脱责任的时候，总喜欢说”你行你上”。 原因：对方不想承担自己的责任。 如何对付”你行你上”?第一步 澄清各自的角色和对方没有什么交集，在意的问题能否解决对实际生活影响很小，那可以简单澄清角色不同，责任自然不一样，所有自己不一定要“行”，也不需要“上”。 例子：我想吃个蛋，难不成自己会下蛋？ 第二步 指出对方在逃避有交集，对方制造的问题有影响，就是指出对方的逻辑漏洞。 原话的逻辑是：有能力的该上，没能力的人不该上。 那么，我承认上的人必须有能力，但是就意味着有能力的人必须上吗？ 第三步 锁定对方的责任当对方的存在本身就影响我们的生活，就可以锁定对方的责任。 三个方法没有优劣和先后之别，因场景稍有不同。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之社交喝酒]]></title>
    <url>%2Fposts%2F47410%2F</url>
    <content type="text"><![CDATA[社交不喝酒，肝脏好朋友； 不擅长喝酒，在酒桌上就很尴尬。 饭桌喝酒，也只是活跃饭桌气氛，未闭合其他人沟通。 饭桌策略：最佳配角策略 当作有人都想在饭桌成为那个最闪亮的人的时候，配角就是最耀眼最抢手的。 如何在酒桌上聊天？选择合适的话题一个会聊天的人是让对方对你知无不言言无不尽，饭局结束都觉得意犹未尽。排除对方的工作（万一对方最近工作烦心）、家庭（除非对方主动提起）、我们所认识的共同的某个朋友。 比较合适话题：年轻人聊星座，有孩子的人聊儿女，没有孩子聊业余爱好。 进行合适的提问，延续话题提问的4W循环原则，中间插入我可能没有你这么棒的感慨，让对方兴致勃勃，可以让话题不断延续。 4W循环原则:喜欢什么？哪个种类？为什么？怎么做到的？ 根据话题归纳有点，进行适当的恭维当话题足够深入时候，我们可以概括对方的中心思想，并进行对对方有点的价值升华，展开恭维。 必须赋予人家的爱好，他本人都没有的想到的牛逼意义。 告诉对方，他的爱好表达了什么样的情操？]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
        <tag>沟通表达</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之道歉]]></title>
    <url>%2Fposts%2F19497%2F</url>
    <content type="text"><![CDATA[道歉是人生的加分项！ 道歉两条红线： 第一：绝不能说这件错没有那么严重； 事情不够糟 第二：绝对不能说这件事不全是我的错； 试图澄清自己的责任不够大 怎么道歉 蚂蚁搬大象 道歉的时候尽可能把责任往自己身上揽，甚至包揽到一个夸张的地步，让想要指责你的人不但不会继续落井下石，甚至可能会反过头来劝上两句。 就像一只蚂蚁搬动大象，搬不动的时候要说：是我自己努力不够，准备不充分，才搬不动的。 这样别人就会说，你怎么会这么想呢？你看着大象这么大，怎么可能是你这只小蚂蚁能够搬得动的呢？对呀，你太过苛责自己了。这也不能全怪你，那些当初比你去搬大象的人他们也要检讨自己。 给人的印象就是，你这只蚂蚁想要很努力的搬动大象的责任，同时本人也发自内心的搬不动是自己的错，这样别人才会觉得搬不动真的不是你的错。 例子：包贝尔婚礼闹伴娘事件（红线），皇帝的罪己诏（蚂蚁搬大象）；]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之自我介绍]]></title>
    <url>%2Fposts%2F12298%2F</url>
    <content type="text"><![CDATA[演说如何自我介绍？ 职场面试，念简历者死！ 面试的时候自我介绍是一个坑。 当面试官问让你自我介绍，不是让你把简历（个人信息，奖项，毕业院校…）背一遍； 而更加深层次的含义是你在最短的时间里给人留下的深刻印象的能力 让面试官记住你 主要有三个步骤。 让面试官记住你的的三个步骤第一步 贴标签绰号：形象、生动、概括力，传播力 自己给自己一个标签。 标签的原则：看起来是缺点，其实是特点，仔细想想是优点的标签； 专属于自己的词，不显得自吹自擂，偷偷把自己给夸了 第二步 讲故事一个有趣生动的故事，让自己的标签有画面感，生动鲜活起来； 故事中加入声音，语气、对话，表情等细节 第三步 谈愿景描述和谐的景象，不要自己说的完美，只需要把自己的特点包装成和公司的需要恰到好处。 例如：强迫症。 精心设计，让别人记住你！]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>生活</tag>
        <tag>好好说话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之砍价]]></title>
    <url>%2Fposts%2F12618%2F</url>
    <content type="text"><![CDATA[谈判如何砍价？ 不懂“掀桌”，只能滚蛋！ 掀桌的三步，一步不能缺第一步表达自己想上桌的意愿，给对方一种稳赚的感觉，把对方拉上谈判桌； 第二步等对方上桌之后，告诉对方还有一个不友好的第三者也在这张桌上，为后面掀桌埋下伏笔，同时也建立一张安全网，让对方依然和你保持一个船上； 第三步当对方给出条件之后，态度立即来个大逆转，从极度开心到极度不开心，吓死对方，让对方面临两种选择交易失败（之前他的所有聊天成本泡汤）和交易继续（接受你的条件），突然把对方一脚踢开； 注意事项不要进店立即问价，要在最后关头问价！ 不完全会成功，因为你的条件要在对方的底线内！ 掀桌的核心不在于掀桌，在于上桌和安全网！]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>生活</tag>
        <tag>好好说话</tag>
        <tag>喜马拉雅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《好好说话》笔记之辞职]]></title>
    <url>%2Fposts%2F4571%2F</url>
    <content type="text"><![CDATA[好的辞职谈话和好的面试表现同样两个重要！ 反例：辞职的时候说的痛快、 畅所欲言； 职场是个小圈子，贴的最久的标签是离职时给人的印象； 马云说：员工离职原因有两种：钱不到位或者心委屈了；归根结底：干的不爽。辞职的时候找靠谱理由是为了给上司留面子。 优质辞职三层意思：告知去处；上司问：接下来怎么安排？如果想保持离职前的人脉，对于离职后的计划不要隐瞒； 反例:有人签好的下一家，却说我要留学，在家休息等无厘头理由 告知去处不是告诉老板你拿到了offer，工资多少； 慎选理由； 反例:直接了当的说薪资和人际问题 温和说：我不太适应这个公司的文化，大家都太内敛了，而我比较外向，个性不太一样。 既不伤人，又表达了原因 表示感激；谈谈在公司收获，成长；辞职后的关系上下级转变为平等（前辈和新人）；请教自己不足和自己的发展；如果老板指责你不忠诚,只能表示遗憾； 感激是为了自己的专业态度，别为感情拖泥带水体现自己的职业性。 例子：关羽挂印封金，辞别曹操，追寻旧主刘备。]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
        <tag>生活</tag>
        <tag>好好说话</tag>
        <tag>喜马拉雅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[self和static的差异]]></title>
    <url>%2Fposts%2F25071%2F</url>
    <content type="text"><![CDATA[在没有继承的情况下是一样的。主要的差异体现在继承的情况下。 差异： self：永远绑定代码所在类。当前定义类static：调用时确定哪个类。当前调用类 123456789101112131415161718192021class Books&#123; public static $title = 'Books'; public static function getTitleSelf() &#123; return self::$title; &#125; public static function getTitleStatic() &#123; return static::$title; &#125;&#125;class SmallBook extends Books&#123; public static $title = 'small';&#125;echo SmallBook::getTitleSelf().'&lt;br /&gt;';echo SmallBook::getTitleStatic().'&lt;br /&gt;';echo Books::getTitleStatic().'';echo Books::getTitleSelf().''; 运行结果： 1234BookssmallBooksBooks]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决安装Samba时浏览器打开不成功]]></title>
    <url>%2Fposts%2F21067%2F</url>
    <content type="text"><![CDATA[最开始以为是配置文件或者服务的问题，同时用testparm检测配置文件没有问题，后面发现是SElinux没有关闭。 如何关闭SELinux第一步 查看selinux状态查看selinux的详细状态，如果为enable则表示为开启 1# /usr/sbin/sestatus -v 第二步 查看selinux的模式1# getenforce 第三步 关闭SELinux 永久性关闭（这样需要重启服务器后生效） 1# sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config 临时性关闭（立即生效，但是重启服务器后失效） 12# setenforce 0#设置selinux为permissive模式（即关闭） 12# setenforce 1#设置selinux为enforcing模式（即开启）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>问题</tag>
      </tags>
  </entry>
</search>
